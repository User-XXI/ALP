# Типовые задачи:



##### 1) Создать класс «целое число».
Элементы класса:
поле задает значение целого числа (статус доступа private);
конструктор для инициализации поля;
метод для вычисления остатка от деления целого числа на 5.
Создать 1 объект данного класса, вывести значение остатка от деления числа
на 5.
```c++
#include <iostream>

/* Создать класс «целое число».
 * Элементы класса: поле задает
 * значение целого числа (статус доступа private);
 * конструктор для инициализации поля;
 * метод для вычисления остатка от деления целого числа на 5.
 * Создать 1 объект данного класса, вывести значение остатка от деления числа на 5. */


class Int {
private:
    int num;
public:
    Int(int num) : num(num) {};

    int getter() {
        return this->num;
    }

    int mod() {
        return this->num % 5;
    }
};

int main() {
    Int test(7);
    std::cout << test.getter() << " mod : " << test.mod();
}
```


##### 2) Создать класс «целое число».
Элементы класса:
поле задает значение целого числа (статус доступа private);
конструктор для инициализации поля;
метод для печати значения числа в шестнадцатеричной системе счисления.
Создать 1 объект данного класса, вывести на печать значение числа в
шестнадцатеричной системе счисления.
```c++
/*
 * Создать класс «целое число». Элементы класса: поле задает
 * значение целого числа (статус доступа private);
 * конструктор для инициализации поля;
 * метод для печати значения числа в шестнадцатеричной системе счисления.
 * Создать 1 объект данного класса, вывести на печать значение числа
 * в шестнадцатеричной системе счисления
 */
#include <string>
#include <iostream>
#include <sstream>

class Int {
private:
    int num;

public:
    Int(int num): num(num){};

    int getter(){ return this->num;}


    std::string Hex() const{
        std::stringstream stream;
        stream << std::hex << this->num;
        return stream.str();

    }

    // Или сразу вывод :
      void hex() const {
      std::cout << std::hex << this->num;
        }
};

int main() {
    Int num(9485);
    std::cout << num.Hex() << " " ;
    num.hex();
}
```
##### 3) Создать класс «символ».
Элементы класса:
поле задает символ (статус доступа private);
конструктор для инициализации поля;
метод для печати кода символа.
Создать 1 объект данного класса, вывести на печать код символ.

```c++
//3) Создать класс «символ».
//Элементы класса:
//поле задает символ (статус доступа private);
//конструктор для инициализации поля;
//метод для печати кода символа.

#include <iostream>

class Char{
private:
    char ch;
public:
    explicit Char(char ch) : ch(ch){};

    size_t getC() const{
        return static_cast<size_t>( this->ch);
    }
};


int main() {
    Char ch('0');

    std::cout << ch.getC();
}
```

##### 4) Создать класс «угол (заданный в градусах)».
Элементы класса:
поле задает значение угла в градусах (статус доступа private);
конструктор для инициализации поля;
метод для вычисления синуса угла.
Создать 1 объект данного класса, вывести значение синуса заданного угла.

```c++
//4) Создать класс «угол (заданный в градусах)».
//Элементы класса:
//поле задает значение угла в градусах (статус доступа private);
//конструктор для инициализации поля;
//метод для вычисления синуса угла.
#include <iostream>
#include "cmath"


class Sin {
private:
    float degree;

public:
    explicit Sin(float deg) : degree(deg){};

    float getSin() const{
        return std::sin(degree);
    }
};


int main() {
    Sin test(45);

    std::cout << test.getSin();
}
```

##### 5) Создать класс «угол (заданный в градусах)».
Элементы класса:
поле задает значение угла в градусах (статус доступа private);
конструктор для инициализации поля;
метод для вычисления косинуса угла.
Создать 1 объект данного класса, вывести значение косинуса заданного угла.

```c++
//5) Создать класс «угол (заданный в градусах)».
//Элементы класса:
//поле задает значение угла в градусах (статус доступа private);
//конструктор для инициализации поля;
//метод для вычисления косинуса угла.
//Создать 1 объект данного класса, вывести значение косинуса заданного угла.





//Создать 1 объект данного класса, напечатать значение площади круга.





//5
#include <iostream>
#include <cmath>


class Degree {
private:
    float degree;

public:
    explicit Degree(float deg) : degree(deg) {};

    float Cos() const {
        return std::cos(degree);
    }
};

int main() {
    // ----- 5 -----
    Degree test(45);
    std::cout << test.Cos() << std::endl;
}
```

##### 6) Создать класс «целое число».
Элементы класса:
поле задает значение целого числа (статус доступа private);
конструктор для инициализации поля;
метод, возвращающий 1, если число четное, и 0, в противном случае.
Создать 1 объект данного класса, проверить четное ли число, вывести
соответствующее сообщение.

```c++
////6) Создать класс «целое число».
////Элементы класса:
////поле задает значение целого числа (статус доступа private);
////конструктор для инициализации поля;
////метод, возвращающий 1, если число четное, и 0, в противном случае.
////Создать 1 объект данного класса, проверить четное ли число, вывести
////соответствующее сообщение.

class Int6 {
private:
    int number;
public:
    explicit Int6(int num) : number(num) {};

    bool isOdd() const {
        return !(this->number % 2);
    }
};

int main() {
    // ----- 6 -----
    Int6 test6(4);
    std::cout << test6.isOdd() << std::endl;
}
```

##### 7) Создать класс «круг».
Элементы класса:
поле задает значение радиуса круга (статус доступа private);
конструктор для инициализации поля;
метод для вычисления площадь круга.
Создать 1 объект данного класса, напечатать значение площади круга.

```c++
//7) Создать класс «круг».
//Элементы класса:
//поле задает значение радиуса круга (статус доступа private);
//конструктор для инициализации поля;
//метод для вычисления площадь круга.



class Circle {
private:
    float radius;
public:
    explicit Circle(float R) : radius(R) {};


    float area() const {
        return M_PI * radius * radius;
    };

};

int main() {
    // ----- 7 -----
    Circle test7(4);
    std::cout << test7.area() << std::endl;
}
```

##### 8) Создать класс «окружность».
Элементы класса:
поле задает значение радиуса окружности (статус доступа private);
конструктор для инициализации поля;
метод для вычисления длины окружности.
Создать 1 объект данного класса, напечатать значение длины окружности.

```c++
//8) Создать класс «окружность».
//Элементы класса:
//поле задает значение радиуса окружности (статус доступа private);
//конструктор для инициализации поля;
//метод для вычисления длины окружности.
//Создать 1 объект данного класса, напечатать значение длины окружности.

class Circle2 {

private:
    double radius;
public:
    explicit Circle2(double R) : radius(R) {};

    double getLength() const  {
        return 2.0 * M_PI * radius;
    }
};
int main() {
    // ----- 8 -----
    Circle2 test8(5);
    std::cout << test8.getLength() << std::endl;
}
```

##### 9) Создать класс «квадрат».
Элементы класса:
поле задает значение длины стороны квадрата (статус доступа private);
конструктор для инициализации поля;
метод для вычисления площади квадрата.
Создать 1 объект данного класса, напечатать значение площади квадрата.

```c++
//9) Создать класс «квадрат».
//Элементы класса:
//поле задает значение длины стороны квадрата (статус доступа private);
//конструктор для инициализации поля;
//метод для вычисления площади квадрата.
//Создать 1 объект данного класса, напечатать значение площади квадрата.

class Square {
private:
    double side;

public:
    explicit Square(double side) : side(side){};

    double area() const {
        return side * side;
    }
};

int main() {
    // ----- 9 ------
    Square test9(5);
    std::cout << test9.area() << std::endl;
}
```

##### 10) Создать класс «квадрат».
Элементы класса:
поле задает значение длины стороны квадрата (статус доступа private);
конструктор для инициализации поля;
метод для вычисления периметра квадрата.
Создать 1 объект данного класса, напечатать значение периметра квадрата.

```c++
//10) Создать класс «квадрат».
//Элементы класса:
//поле задает значение длины стороны квадрата (статус доступа private);
//конструктор для инициализации поля;
//метод для вычисления периметра квадрата.

class Square2 {
private:
    double side;

public:
    explicit Square2(double side) : side(side){};

    double perimeter() const {
        return 4 * side;
    }
};


int main() {
    // ----- 10 -----
    Square2 test10(5);
    std::cout << test10.perimeter() << std::endl;
}
```

##### 11) Создать класс базовый класс «точка на плоскости».
Элементы класса:
поля, задающие координаты точки (вещественные поля статус доступа
protected);
конструктор для инициализации полей;
метод для печати значений полей.
Создать производный класс «точка в трехмерном пространстве».
Элементы класса:
дополнительное поле, задающее дополнительную координату;
конструктор для инициализации полей;
переопределенный метод для печати значений полей (внутри
переопределенного метода в первую очередь должен вызываться метод из
базового класса).
Создать по 1 объекту каждого из классов. Объявить переменную - указатель,
имеющею тип базового класса, вначале настроить ее на объект базового
класса, вызвать метод базового класса через указатель на объект. Затем
настроить ее на объект производного класса, вызвать метод производного
класса через указатель на объект. Обеспечить динамический полиморфизм.
```c++
// 11) Создать класс базовый класс «точка на плоскости».
//Элементы класса:
//поля, задающие координаты точки (вещественные поля статус доступа
//protected);
//конструктор для инициализации полей;
//метод для печати значений полей.
//Создать производный класс «точка в трехмерном пространстве».
//Элементы класса:
//дополнительное поле, задающее дополнительную координату;
//конструктор для инициализации полей;
//переопределенный метод для печати значений полей (внутри
//переопределенного метода в первую очередь должен вызываться метод из
//базового класса).
//Создать по 1 объекту каждого из классов. Объявить переменную - указатель,
//имеющею тип базового класса, вначале настроить ее на объект базового
//класса, вызвать метод базового класса через указатель на объект. Затем
//настроить ее на объект производного класса, вызвать метод производного
//класса через указатель на объект. Обеспечить динамический полиморфизм.
#include <iostream>

class Point2D {
protected:
    double x, y;
public:
    Point2D(double x, double y) : x(x), y(y) {};

    virtual void print() const {
        std::cout << "(" << x << ", " << y << ")" << std::endl;
    }
};

class Point3D : public Point2D {
protected:
    double z;
public:
    Point3D(double x, double y, double z) : Point2D(x, y), z(z) {};


    virtual void print() const {
        Point2D::print();
        std:: cout << "(" << z << ")"<< std::endl;
    }


};



int main () {
    //Создать по 1 объекту каждого из классов. Объявить переменную - указатель,
//имеющею тип базового класса, вначале настроить ее на объект базового
//класса, вызвать метод базового класса через указатель на объект. Затем
//настроить ее на объект производного класса, вызвать метод производного
//класса через указатель на объект. Обеспечить динамический полиморфизм.

//С помощью простых переопределенных функций
//реализуется механизм статического полиморфизма. (Полиморфизм –
//возможность функции в производном классе работать по-другому).

//Суть статического связывания: когда указатель одного типа ссылается на
//объект другого типа при наследовании классов, то выбор переопределенного
//метода определяется типом указателя, а не типом объекта.

//Суть динамического связывания: когда указатель одного типа ссылается на
//объект другого типа при наследовании классов, то выбор переопределенного
//метода определяется типом объекта, а не типом указателя, для этого
//переопределенный метод должен быть объявлен виртуальным в базовом классе


    Point2D point2D(1,2);
    Point3D point3D(1,2,3);

    Point2D *pPoint = &point2D;

    pPoint->print();

    pPoint = &point3D;

    pPoint->print();
} 
```


##### 12) Создать класс базовый класс «вектор на плоскости».
Элементы класса:
поля, задающие координаты точки (вещественные поля статус доступа
protected), определяющей конец вектора (начало вектора находится в точке с
координатами 0, 0);
конструктор для инициализации полей;
метод для вычисления длины вектора
метод для печати полей и длины вектора.
Создать производный класс «вектор в трехмерном пространстве».
Элементы класса:
дополнительное поле, задающее дополнительную координату;
конструктор для инициализации полей;
переопределенный метод для вычисления длины вектора
переопределенный метод для печати полей и длины вектора (внутри
переопределенного метода в первую очередь должен вызываться метод из
базового класса).
Создать по 1 объекту каждого из классов. Объявить переменную - указатель,
имеющею тип базового класса, вначале настроить ее на объект базового
класса, вызвать метод базового класса через указатель на объект. Затем
настроить ее на объект производного класса, вызвать метод производного
класса через указатель на объект. Обеспечить динамический полиморфизм.
```c++
//12) Создать класс базовый класс «вектор на плоскости».
//Элементы класса:
//поля, задающие координаты точки (вещественные поля статус доступа
//protected), определяющей конец вектора (начало вектора находится в точке с
//координатами 0, 0);
//конструктор для инициализации полей;
//метод для вычисления длины вектора
//метод для печати полей и длины вектора.
//Создать производный класс «вектор в трехмерном пространстве».
//Элементы класса:
//дополнительное поле, задающее дополнительную координату;
//конструктор для инициализации полей;
//переопределенный метод для вычисления длины вектора
//переопределенный метод для печати полей и длины вектора (внутри
//переопределенного метода в первую очередь должен вызываться метод из
//базового класса).
//Создать по 1 объекту каждого из классов. Объявить переменную - указатель,
//имеющею тип базового класса, вначале настроить ее на объект базового
//класса, вызвать метод базового класса через указатель на объект. Затем
//настроить ее на объект производного класса, вызвать метод производного
//класса через указатель на объект. Обеспечить динамический полиморфизм.

#include <iostream>
#include "cmath"

class Vector2D{
protected:
    double x,y;
public:
    Vector2D(double x , double y) : x(x), y(y){};

    virtual double Length() {
        return sqrt((x*x + y*y));
    }

    virtual void print() {
        std::cout << " x :" << x << " y: " << y << " ";
    }

    virtual void printLen() {
        std::cout << "\n Len is " << this->Length() << std::endl;
    }
};

class Vector3D : public Vector2D{
protected:
    double x,y,z;

public:
    Vector3D(double x, double y, double z) : Vector2D(x,y), z(z){};

    double Length() {
        return sqrt((x*x + y*y + z*z));
    }

    void print() {
        Vector2D::print();
        std::cout << this->z << std::endl;
    }

    virtual void printLen() {
        std::cout << "\n Len is " << this->Length() << std::endl;
    }


};

////Создать по 1 объекту каждого из классов. Объявить переменную - указатель,
////имеющею тип базового класса, вначале настроить ее на объект базового
////класса, вызвать метод базового класса через указатель на объект. Затем
////настроить ее на объект производного класса, вызвать метод производного
////класса через указатель на объект. Обеспечить динамический полиморфизм.

int main() {
    Vector2D vector2d(1,2);
    Vector3D vector3d(1,2,3);

    Vector2D *pvector = &vector2d;

    pvector->print();
    pvector->printLen();

    pvector = &vector3d;

    pvector->print();
    pvector->printLen();

}
```
##### 13) Создать класс базовый класс «квадрат».
Элементы класса:
поле, задающее длину стороны;
конструктор для инициализации поля;
метод для вычисления площади квадрата;
метод для печати поля и площади квадрата.
Создать производный класс «куб».
Элементы класса:
конструктор для инициализации поля;
переопределенный метод для вычисления объема куба (вместо площади)
(внутри переопределенного метода должен вызываться метод из базового
класса).
Создать по 1 объекту каждого из классов. Объявить переменную - указатель,
имеющею тип базового класса, вначале настроить ее на объект базового
класса, вызвать метод базового класса через указатель на объект. Затем
настроить ее на объект производного класса, вызвать метод производного
класса через указатель на объект. Обеспечить статический полиморфизм.
```c++
//13) Создать класс базовый класс «квадрат».
//Элементы класса:
//поле, задающее длину стороны;
//конструктор для инициализации поля;
//метод для вычисления площади квадрата;
//метод для печати поля и площади квадрата.
//Создать производный класс «куб».
//Элементы класса:
//конструктор для инициализации поля;
//переопределенный метод для вычисления объема куба (вместо площади)
//(внутри переопределенного метода должен вызываться метод из базового
//класса).
//Соз13) Создать класс базовый класс «квадрат».
//Элементы класса:
//поле, задающее длину стороны;
//конструктор для инициализации поля;
//метод для вычисления площади квадрата;
//метод для печати поля и площади квадрата.
//Создать производный класс «куб».
//Элементы класса:
//конструктор для инициализации поля;
//переопределенный метод для вычисления объема куба (вместо площади)
//(внутри переопределенного метода должен вызываться метод из базового
//класса).
//Создать по 1 объекту каждого из классов. Объявить переменную - указатель,
//имеющею тип базового класса, вначале настроить ее на объект базового
//класса, вызвать метод базового класса через указатель на объект. Затем
//настроить ее на объект производного класса, вызвать метод производного
//класса через указатель на объект. Обеспечить статический полиморфизм.дать по 1 объекту каждого из классов. Объявить переменную - указатель,
//имеющею тип базового класса, вначале настроить ее на объект базового
//класса, вызвать метод базового класса через указатель на объект. Затем
//настроить ее на объект производного класса, вызвать метод производного
//класса через указатель на объект. Обеспечить статический полиморфизм.


#include <iostream>
#include <cmath>

class Square {
protected:
    double side;
public:
    explicit Square(double side) : side(side){};

    double calc() const {
        return side * side;
    };

    void print() {
        std::cout << "Side : " << side << " Area : " << this->calc() << std::endl;
    }

};

class Cube : public Square {
protected:
    double side;
public:
    explicit Cube(double side) : Square(side){};

    double calc() const {
        return Square::calc() * side;
    }

    void print() {
        Square::print();
        std::cout << " Vol " << this->calc() << std::endl;
    }
};


int main() {

    Square square(5);

    Cube cube(5);

    Square *psq = &square;

    // Статический полиформизм

    psq->print();

    psq = &cube;
    psq->print();

}
```
##### 14) Создать класс базовый класс «прямоугольник».
Элементы класса:
поля, задающие длины сторон;
конструктор для инициализации полей;
метод для вычисления площади прямоугольника;
метод для печати полей и значения площади.
Создать производный класс «прямоугольный параллелепипед».
Элементы класса:
дополнительное поле, задающее высоту;
конструктор для инициализации полей;
переопределенный метод для вычисления объема (вместо площади) (внутри
переопределенного метода должен вызываться метод из базового класса);
переопределенный метод для печати полей и значения объема.
Создать по 1 объекту каждого из классов. Объявить переменную - указатель,
имеющею тип базового класса, вначале настроить ее на объект базового
класса, вызвать метод базового класса через указатель на объект. Затем
настроить ее на объект производного класса, вызвать метод производного
класса через указатель на объект. Обеспечить статический полиморфизм.

```c++
#include <iostream>

class rectangle {
protected:
    double a, b;
public:
    rectangle (double length, double width): a(length), b(width){}

    virtual double calc (){
        return a * b;
    }

    virtual void print (){
        std::cout << "length: " << a << "\nwidth: " << b << "\nSquare: " << calc() << std::endl;
    }
};

class cuboid : public rectangle {
protected:
    double c;
public:
    cuboid (double length, double width, double height): rectangle(length, width), c(height){}

    double calc(){
        return rectangle::calc() * c;
    }

    void print(){
        rectangle::print();
        std::cout << "height: " << c << "\nVolume: " << calc() << std::endl;
    }
};

int main(){
    rectangle my_rec (4, 5.5);

    cuboid my_cuboid (4, 5.5, 7);

    rectangle *pRC = &my_rec;

    pRC -> print();

    pRC = &my_cuboid;

    pRC -> print();
}
```

##### 15) Создать класс базовый класс «круг».
Элементы класса:
поле, задающее радиус;
конструктор для инициализации поля;
метод для вычисления площади круга (площадь круга 𝜋𝑟2);
метод для печати полей и площади.
Создать производный класс «шар».
Элементы класса:
конструктор для инициализации поля;
переопределенный метод для вычисления объема (вместо площади круга)
шара (площадь шара 4
3 𝜋𝑟3).
Создать по 1 объекту каждого из классов. Объявить переменную - указатель,
имеющею тип базового класса, вначале настроить ее на объект базового
класса, вызвать метод базового класса через указатель на объект. Затем
настроить ее на объект производного класса, вызвать метод производного
класса через указатель на объект. Обеспечить динамический полиморфизм.

```c++
#include <iostream>
#include <cmath>

class circle{
protected:
    double R;
public:
    explicit circle (double radius): R(radius){}

    virtual double calc(){
        return 3.14159 * std::pow(R, 2);
    }

    virtual void print(){
        std::cout << "Radius: " << R << "\nSquare: " << calc() << std::endl;
    }
};

class sphere : public circle{
public:
    explicit sphere(double radius): circle(radius){}

    double calc(){
        return circle::calc() * 4 / 3 * R;
    }

    void print(){
        std::cout << "Radius: " << R << "\nVolume: " << calc() << std::endl;
    }
};

int main(){
    circle c1(1.5);
    sphere sp1(2);

    circle *pC = &c1;

    pC -> print();

    pC = &sp1;
    pC -> print();
    return 0;
}
```



##### 16) Создать класс базовый класс «автомобиль».
Элементы класса:
поле, содержащее наименование модели автомобиля;
поле, содержащее значение максимальной скорости;
конструктор для инициализации полей;
метод для печати параметров автомобиля.
Создать производный класс «грузовой автомобиль».
Элементы класса:
дополнительно поле, содержащее грузоподъемность автомобиля в тоннах;
конструктор для инициализации полей;
переопределенный метод печати параметров автомобиля (внутри
переопределенного метода должен вызываться метод из базового класса).
Создать по 1 объекту каждого из классов. Объявить переменную - указатель,
имеющею тип базового класса, вначале настроить ее на объект базового
класса, вызвать метод базового класса через указатель на объект. Затем
настроить ее на объект производного класса, вызвать метод производного
класса через указатель на объект. Обеспечить динамический полиморфизм.

```c++
#include <iostream>
#include <string>

class automobile{
protected:
    std::string _id;
    int _max_speed;
public:
    automobile (std::string  name, int speed): _id(name), _max_speed(speed){}

    virtual void print(){
        std::cout << "Name: " << _id << "\nMax speed: " << _max_speed << std::endl;
    }
};

class truck : public automobile{
protected:
    double _load_capacity;
public:
    truck(std::string  name, int speed, double capacity): automobile(name, speed),  _load_capacity(capacity/1000){}

    void print(){
        automobile::print();
        std::cout << "Load capacity (in tons): " << _load_capacity;
    }
};

int main(){
    automobile car1("suzuki" ,320);
    truck mersedes1("mersedes", 200, 5200);

    automobile *pCR1 = &car1;
    pCR1 -> print();

    pCR1 = & mersedes1;
    pCR1 -> print();
    return 0;
}
```


##### 17) Создать класс базовый класс «вещественное число».
Элементы класса:
поле, задающее значение числа;
конструктор для инициализации поля;
метод для вычисления модуля числа;
метод для печати поля и модуля числа.
Создать производный класс «комплексное число».
Элементы класса:
дополнительно поле, задающее значение мнимой части числа;
конструктор для инициализации полей;
переопределенный метод для вычисления модуля числа (модуль числа –
корень квадратный из суммы квадратов вещественной и мнимой частей
числа);
переопределенный метод для печати полей и модуля числа (внутри
переопределенного метода должен вызываться метод из базового класса).
Создать по 1 объекту каждого из классов. Объявить переменную - указатель,
имеющею тип базового класса, вначале настроить ее на объект базового
класса, вызвать метод базового класса через указатель на объект. Затем
настроить ее на объект производного класса, вызвать метод производного
класса через указатель на объект. Обеспечить динамический полиморфизм.

```c++
#include <iostream>
#include <cmath>

class real_number{
protected:
    float number;
public:
    real_number(float  value): number(value){}

    virtual float abs1(){
        return std::abs(number);
    }

    virtual void print() {
        std::cout << "Number: " << number << "\nAbsolute: "<< abs1() << std::endl;
    }
};

class complex_number : public real_number{
protected:
    float imaginary;
public:
    complex_number(float value1, float value2): real_number(value1), imaginary(value2){}

    float abs1(){
        return std::sqrt(number*number + imaginary*imaginary);
    }

    void print(){
        std::cout << "Imaginary: " << imaginary << std::endl;
        real_number::print();
    }
};

int main(){
    real_number num1 (-1.4);
    complex_number num2(1.4, -2.6);

    real_number* pNUM = &num1;

    pNUM -> print();

    pNUM = &num2;
    pNUM-> print();
    return 0;
}
```

##### 18) Создать класс базовый класс «сотрудник компании».
Элементы класса:
поле, содержащее ФИО сотрудника;
поле, содержащее размер оклада (статус доступа protected);
конструктор для инициализации полей;
метод для печати ФИО и размера оклада сотрудника.
Создать производный класс «начальник подразделения компании».
Элементы класса:
дополнительное поле, содержащее надбавку к зарплате за исполнение
обязанностей начальника;
конструктор для инициализации полей;
переопределенный метод печати ФИО, размера оклада и размера зарплаты
начальника (зарплата считается как сумма оклада и надбавки) (внутри
переопределенного метода должен вызываться метод из базового класса).
Создать по 1 объекту каждого из классов. Объявить переменную - указатель,
имеющею тип базового класса, вначале настроить ее на объект базового
класса, вызвать метод базового класса через указатель на объект. Затем
настроить ее на объект производного класса, вызвать метод производного
класса через указатель на объект. Обеспечить статический полиморфизм.

```c++
#include <iostream>
#include <string>

class employee{
protected:
    std::string FIO;
    float salary;
public:
    employee (std::string fio, float value): FIO(fio), salary(value){}

    void print(){
        std::cout << "FIO: " << FIO << "\nSalary: " << salary << std::endl;
    }
};

class chief : public employee{
protected:
    float allowance;
public:
    chief (std::string fio, float value, float extra_value): employee(fio, value), allowance(extra_value){}

    void print(){
        employee::print();
        std::cout << "Salary with allowance: " << salary + allowance << std::endl;
    }
};

int main(){
    employee worker1("Ivan Ivanov", 1500);
    chief worker2("Andrew Ivanov", 1500, 200);

    employee* pWR = &worker2;

    pWR -> print();

    pWR =&worker2;

    pWR -> print();
    return 0;
}
```

##### 19) Создать класс базовый класс «вектор на плоскости».
Элементы класса:
поля, задающие координаты точки (вещественные поля статус доступа
protected), определяющей конец вектора (начало вектора находится в точке с
координатами 0, 0);
конструктор для инициализации полей;
метод для печати координат вектора.
Создать производный класс «вектор в трехмерном пространстве».
Элементы класса:
дополнительное поле, задающее дополнительную координату;
конструктор для инициализации полей;
переопределенный метод для печати координат вектора (внутри
переопределенного метода должен вызываться метод из базового класса).
Создать по 1 объекту каждого из классов. Объявить переменную - указатель,
имеющею тип базового класса, вначале настроить ее на объект базового
класса, вызвать метод базового класса через указатель на объект. Затем
настроить ее на объект производного класса, вызвать метод производного
класса через указатель на объект. Обеспечить статический полиморфизм.

```c++
#include <iostream>

class my_vec_2D{
protected:
    float x;
    float y;
public:
    my_vec_2D(float x1, float y1): x(x1), y(y1){}

    void print(){
        std::cout << "X: " << x << "\nY: " << y << std::endl;
    }
};

class my_vec_3D : public my_vec_2D{
protected:
    float z;
public:
    my_vec_3D(float x1, float y1, float z1): my_vec_2D(x1, y1), z(z1){}

    void print(){
        my_vec_2D::print();
        std::cout << "Z: " << z << std::endl;
    }
};

int main(){
    my_vec_2D vec1(1, 2);
    my_vec_3D vec2(3, 5, 4);

    my_vec_2D* pMV = &vec1;

    pMV -> print();

    pMV = &vec2;
    pMV->print();
}
```

##### 20) Создать класс базовый класс «квадрат».
Элементы класса:
поле, задающее длину стороны;
конструктор для инициализации поля;
метод для вычисления периметра квадрата;
метод для печати длины стороны и периметра.
Создать производный класс «прямоугольник».
Элементы класса:
дополнительное поле, задающее другую сторону;
конструктор для инициализации полей;
переопределенный метод для вычисления периметра прямоугольника;
переопределенный метод для печати длин сторон и периметра (внутри
переопределенного метода должен вызываться метод из базового класса).
Создать по 1 объекту каждого из классов. Объявить переменную - указатель,
имеющею тип базового класса, вначале настроить ее на объект базового
класса, вызвать метод базового класса через указатель на объект. Затем
настроить ее на объект производного класса, вызвать метод производного
класса через указатель на объект. Обеспечить статический полиморфизм.

```c++
#include <iostream>
class square{
protected:
    float a;
public:
    explicit square(float side): a(side){}
    float perimeter() const{
        return a * 4;
    }
    void print() const{
        std::cout << "length: " << a << "\nPerimeter: " << perimeter() << std::endl;
    }
};
class rectangle : public square{
protected:
    float b;
public:
    rectangle (float length, float width): square(length), b(width){}
    float perimeter() const{
        return (a + b) * 2;
    }
    void print() const{
        std::cout << "width: " << b << std::endl;
        square::print();
    }
};
int main(){
    square my_sq(4.5);
    rectangle my_rc(4.75,2);

    square* pSQ = &my_sq;
    pSQ -> print();
    
    pSQ = &my_rc;
    pSQ -> print();
}
```

##### 21) Реализовать класс «Время». Поля: часы, минуты, секунды.
Конструкторы: конструктор для инициализации полей. При
недопустимых параметрах объекта создается исключение. Для
исключения создать класс, производный от out_of_range.
Дополнительно созданный класс для исключения содержит поля
класса «Время» для недопустимого объекта и метод для печати всех
данных. Продемонстрировать работу с объектами в случае
возникновения исключения и без возникновения исключения.
```c++
//21) Реализовать класс «Время». Поля: часы, минуты, секунды.
//Конструкторы: конструктор для инициализации полей. При
//недопустимых параметрах объекта создается исключение. Для
//исключения создать класс, производный от out_of_range.
//Дополнительно созданный класс для исключения содержит поля
//класса «Время» для недопустимого объекта и метод для печати всех
//данных. Продемонстрировать работу с объектами в случае
//возникновения исключения и без возникновения исключения.
#include <stdexcept>
#include <iostream>
class IncorrectTime : std::out_of_range {
	private:
		int hours;
		int minutes;
		int seconds;
	public:
		IncorrectTime( int h, int m, int s) : out_of_range("Incorrect time"),
                                                                     hours(h),
                                                                     minutes(m), seconds(s) {
            std::cout << "WRONG ! : " << h << " " << m << " " << s << std::endl;
        };


};


class Time {
private:
    unsigned int hours;
    unsigned int minutes;
    unsigned int seconds;

public:
    Time(int h, int m, int s) {
	    if ( h > 24 || m > 59 || s > 59) throw IncorrectTime(h,m,s);
        hours =h;
        minutes = m;
        seconds = s;
    };

    void print(){
        std::cout << hours << " "<< minutes << " " << seconds << " " << std::endl;
    }


};


int main() {
    Time today(23,55,44);
    try {
    Time wrong(23,69,45);
    }
    catch (IncorrectTime) {
	//std::cout << "wrong time";
    }
    today.print();
    //wrong.print();
}
```
##### 22) Реализовать класс «Дата». Поля: число, месяц, год.
Конструкторы: конструктор для инициализации полей. При
недопустимых параметрах объекта создается исключение. Для
исключения создать класс, производный от out_of_range.
Дополнительно созданный класс для исключения содержит поля
класса «Дата» для недопустимого объекта и метод для печати всех
данных. Продемонстрировать работу с объектами в случае
возникновения исключения и без возникновения исключения.
```c++
//22) Реализовать класс «Дата». Поля: число, месяц, год.
//Конструкторы: конструктор для инициализации полей. При
//недопустимых параметрах объекта создается исключение. Для
//исключения создать класс, производный от out_of_range.
//Дополнительно созданный класс для исключения содержит поля
//класса «Дата» для недопустимого объекта и метод для печати всех
//данных. Продемонстрировать работу с объектами в случае




//возникновения исключения и без возникновения исключения


#include <iostream>
#include <stdexcept>



class WrongDate : std::out_of_range {

	private:
		int day, month,year;

	public: WrongDate(int d, int m, int y) : out_of_range("Wrong date"), day(d), month(m), year(y) {

			std::cout << "Wrong ! : " << d << " " << m << " " << y << std::endl;
		};


};



class Date {

private:
	int day, month,year;

public:
	Date(int d, int m, int y) {
		if (d > 31 || m > 12) throw WrongDate(d,m,y);
		day = d; month = m; year = y;

	};

	void print() {

		std::cout << day << "." << month << "." << year << std::endl;}



};

int main() {


Date rigt(26,05,2004);
try {
Date wrong(31,25,203);
}

catch (WrongDate) {std::cout << "the date was worng" << std::endl;}
rigt.print();
}
```

##### 23) Разработать функцию для печати n первых значений натуральных
чисел (1, 2, 3, ..., n), параметры функции: n и имя потока. Функция
печатает имя потока и значение очередного числа на одной строке,
далее переход на новую строку. Создать два разных потока для печати
двух последовательностей одновременно, обеспечить синхронизацию
при печати каждой строки текста (строка печатается потоком
полностью, исключить возможность вставки в нее данных другого
потока).
```c++
//23) Разработать функцию для печати n первых значений натуральных
//чисел (1, 2, 3, ..., n), параметры функции: n и имя потока. Функция
//печатает имя потока и значение очередного числа на одной строке,
//далее переход на новую строку. Создать два разных потока для печати
//двух последовательностей одновременно, обеспечить синхронизацию
//при печати каждой строки текста (строка печатается потоком
//полностью, исключить возможность вставки в нее данных другого
//потока).

#include <string>
#include <iostream>
#include <thread>
#include <future>
#include <mutex>


std::mutex mutex;


void print(int n, const std::string &tname) {
    for (size_t x = 1; x < n + 1; ++x) {
        mutex.lock();
        std::cout << tname << " " << x << std::endl;
        mutex.unlock();
    }
}

int main() {
    std::thread thread1(print, 50, "thread1");
    std::thread thread2(print, 50, "thread2");
    thread1.join();
    thread2.join();
}
```
##### 24) Разработать функцию для печати n значений псевдослучайных
чисел (ПСЧ), параметры функции: n и имя потока. Функция печатает
имя потока и значение очередного ПСЧ на одной строке, далее переход
на новую строку. Создать два разных потока для печати двух
последовательностей ПСЧ, обеспечить синхронизацию при печати
каждой строки текста (строка печатается потоком полностью,
исключить возможность вставки в нее данных другого потока).
```c++
//24) Разработать функцию для печати n значений псевдослучайных
//чисел (ПСЧ), параметры функции: n и имя потока. Функция печатает
//имя потока и значение очередного ПСЧ на одной строке, далее переход
//на новую строку. Создать два разных потока для печати двух
//последовательностей ПСЧ, обеспечить синхронизацию при печати
//каждой строки текста (строка печатается потоком полностью,
//исключить возможность вставки в нее данных другого потока).

#include <thread>
#include <iostream>
#include <random>
#include <mutex>
#include <ctime>
#include <mutex>

std::mutex mutex;


void print(int n, const std::string &tname) {
    for (size_t x = 0; x < n ; ++x) {
        mutex.lock();
        std::cout << tname << " " << random() % 100 << std::endl;
        mutex.unlock();
    }
}

int main() {
    std::thread thread1(print, 50, "thread1");
    std::thread thread2(print, 50, "thread2");
    thread1.join();
    thread2.join();
} 
```

##### 25) Разработать функцию для печати n первых значений натуральных
чисел (1, 2, 3, ..., n), параметры функции: n и имя потока. Функция
печатает имя потока и значение очередного числа на одной строке,
далее переход на новую строку. Создать поток, используя эту
функцию, при этом главный поток переходит в режим ожидания
приема оповещения от дочернего потока. Дочерний поток после
завершения печати посылает оповещение главному потоку, главный
поток принимает оповещение и печатает сообщение об этом событии.
Для посылки и приема оповещений использовать условную
переменную (объект класса std::condition_variable).

```c++
//25) Разработать функцию для печати n первых значений натуральных
//чисел (1, 2, 3, ..., n), параметры функции: n и имя потока. Функция
//печатает имя потока и значение очередного числа на одной строке,
//далее переход на новую строку. Создать поток, используя эту
//функцию, при этом главный поток переходит в режим ожидания
//приема оповещения от дочернего потока. Дочерний поток после
//завершения печати посылает оповещение главному потоку, главный
//поток принимает оповещение и печатает сообщение об этом событии.
//Для посылки и приема оповещений использовать условную
//переменную (объект класса std::condition_variable).


#include <condition_variable>
#include <thread>
#include <iostream>
std::mutex mutex;
std::condition_variable conditionVariable;
bool flag = false;

void daughter(int n, const std::string &tname) {
    std::unique_lock<std::mutex> lock(mutex);

    while (!flag) conditionVariable.wait(lock);
    for (size_t x = 0; x < n ; ++x) {
        std::cout << tname << " " << rand() % 100 << std::endl;
    }
    flag = false;
}

void parent(int n, const std::string &tname) {
    std::cout << tname << "STARTING ! " << std::endl;
    for (size_t x = 0; x < 10 ; ++x) {
        std::cout << tname << " " << x << std::endl;
    }
    std::cout << tname << " FINISHED? NOTIFY CF" << std::endl;
    flag = true;
    conditionVariable.notify_all();
}

int main() {
    std::thread thread1(parent, 50, "thread1");
    std::thread thread2(daughter, 50, "thread2");
    thread1.join();
    thread2.join();
} 
```

##### 26) Разработать функцию для печати n значений псевдослучайных
чисел (ПСЧ), параметры функции: n и имя потока. Функция печатает
имя потока и значение очередного ПСЧ на одной строке, далее переход
на новую строку. Создать поток, используя эту функцию, при этом
главный поток переходит в режим ожидания приема оповещения от
дочернего потока. Дочерний поток после завершения печати посылает
оповещение главному потоку, главный поток принимает оповещение и
печатает сообщение об этом событии. Для посылки и приема
оповещений использовать условную переменную (объект класса
std::condition_variable).
 ```c++ 
//26) Разработать функцию для печати n значений псевдослучайных
//чисел (ПСЧ), параметры функции: n и имя потока. Функция печатает
//имя потока и значение очередного ПСЧ на одной строке, далее переход
//на новую строку. Создать поток, используя эту функцию, при этом
//главный поток переходит в режим ожидания приема оповещения от
//дочернего потока. Дочерний поток после завершения печати посылает
//оповещение главному потоку, главный поток принимает оповещение и
//печатает сообщение об этом событии. Для посылки и приема
//оповещений использовать условную переменную (объект класса
//std::condition_variable).
#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <string>
#include <condition_variable>

std::condition_variable cv;
std::mutex gMutex;
bool isDone = false;

void printNumbers(int n, const std::string &name)
{
    std::unique_lock<std::mutex> lock(gMutex);
    for (int i = 0; i < n; i++) {
        std::cout << name << ": " << i << std::endl;
    }

    isDone = true;
    cv.notify_one();
}

int main()
{
    static const int N = 1000;
    static const std::string NAME = "thread1";

    std::thread thread(printNumbers, N, std::ref(NAME));
    std::unique_lock<std::mutex> lock(gMutex);

    while (!isDone) {
        cv.wait(lock);
    }

    thread.join();      // Ждем, пока оно деструкторы довыполняет т.п.
    std::cout << "Done!" << std::endl;

    return 0;
}
  ```
