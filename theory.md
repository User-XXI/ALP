### 1. Классы в языке Си++: объявление, поля и функции (методы) классов. Определение функций внутри класса и за пределами класса, примеры.

Классы

```c++
Класс в языке Си++ – это новый тип, определяемый программистом, 
включающий данные (поля класса) и методы (функции) для обработки этих данных. 
Переменные этого типа называются объектами.
```
```c++
Можно дать такое определение класса через структуру, которая была в языке Си.

Класс – это структура, в которую введены методы для обработки полей.
Объекты – это переменные типа класса. 
```
Объявление
```c++
Формат объявления класса:
<Ключевое слово> <Имя_класса>
{
 <список компонент>
};

В качестве ключевого слова используется одно из трех ключевых слов:
- struct
- class
- union
```
```c++
Формат определения объектов:
<Имя_класса> <Имя_объекта1>,…<Имя_объекта_N>;
```
Поля и методы
```c++
struct Complex {
    double real,  image; // Поля класса 
    void define(double re=0.0, double im=0.0)   // 
	// Определение метода внутри класса, метод будет подставляемым
    {
    real=re; image=im;// Обращение к полям внутри метода
    }
    void print(); // Описание метода
};

void Complex::print() // Определение метода за пределами класса
{
    printf("\nreal=%f  image=%f", real, image); 
}
```
Перегрузки
```c++
Возможна перегрузка методов.
Чаще всего класс объявляется в 2-х файлах: 
− заголовочный файл с расширением .h, содержит описание класса с заголовками методов; 
− файл реализации с расширением .cpp, содержит определения методов за пределами класса.

При необходимости использовать класс в каким-либо файле проекта, 
к этому файлу требуется подключить заголовочный файл с описанием класса.
В последних допустимо объявление полей класса с инициализацией 
(в ранних версиях это было запрещено).

Инициализация выполняется до выполнения конструктора. 
Функция класса может иметь модификатор const, 
это означает, что она не может изменять поля класса, 
кроме полей с модификатором mutable
```
```c++
class point
{
    int x=-10;
    mutable int y=-10;
public:
    void print() const;
……
};

void point::print() const // Определение метода за пределами класса с модификатором const
{
    cout<<"\nx="<<x<<" y="<<y; 
	y = 10; // Было бы запрещено, если бы y был без mutable
}
```
Конструктор
```c++
Конструктор класса специальный блок операторов (инструкций), 
вызываемый при создании объекта. 
Назначение: 
присвоение нач. значений полям, 
выделение памяти, 
открытие файлов, 
сетевых соединений и т.п. 

Имя конструктора совпадает с именем класса, 
конструктор не имеет возвращаемого значения. 

Возможна перегрузка конструкторов. 
```
```c++
Конструктор может определяться как внутри класса, так и за пределами.
Формат определения конструктора внутри класса: 
Имя_класса(Список_формальных_параметров) {Операторы_тела конструктора} 

По умолчанию класс всегда имеет конструктор копирования вида 
A(const A& a) {… } (A – имя класса), 
создающий копию объекта (происходит копирование полей), 
и, если нет ни одного явного конструктора, 
то по умолчанию создается конструктор без параметров. 
Эти конструкторы можно переопределять. 

Конструктор копирования по умолчанию можно удалить, 
для этого в классе заголовок конструктора объявляется с ключевым словом delete без тела, 
например, A(const A& a)=delete; 
Если нет явного конструктора копирования, 
то конструктор копирования по умолчанию будет удален при наличии явного конструктора перемещения 
(см. ниже) или оператора копирования с перемещением.
```
```c++
Примеры вызовов конструкторов:
    A a1;  A* pA=new A; // Вызываются конструкторы без параметров
    A a2(3, 4); A * pA2=new A(3, 4);
    // Вызываются конструкторы с 2-мя параметрами 

Для конструктора с одним параметром можно использовать форму:
    A a1=5; A a2=a1; 
	// Вместо 
	A a1(5); A a2(a1);
	
Ключевое слово explicit у конструктора с одним параметром запрещает это преобразование, 
допустима явная форма: 
    A a1(5); A a2(a1);
```
```c++
Пример:
class point
{
    int x, y;
public:
    point(int, int); // Конструктор с 2-мя параметрами 
	explicit point(int); // Конструктор с 1-м параметром 
	point() : x(0), y(0)  // Можно иницилизировать поля так 
	{ // Конструктор без параметров 
		// x=0; y=0;     // Или так
        cout << endl << "point()";
    }
    void print(); 
	~point(){
    printf("\nDestructor");
    }
};

point::point(int a, int b) // Определение конструктора за пределами класса 
    : x(a), y(b) // Можно так
{
    // x=a; y=b; // Или так
}

point::point(int a) // Определение конструктора за пределами класса
{
    x=a; y=0;
}

void point::print() // Определение метода за пределами класса
{
	cout<<"\nx="<<x<<" y="<<y;
}

	int main(int argc, char* argv[]) {
	point *pP=new point[10]; // Массив указателей на объеты, создается 10 объектов, 
			 // вызываются конструкторы без параметров
	point p1(12, 13); 
	p1.print();
	point p2; // Вызов конструктора без параметров 
	point p3=100; // point p3(100); Вызов конструктора с 1-м параметром Ошибка, надо
				// point p3(100); так как есть explicit у конструктора
	p2.print(); 
	p3.print();
	point p4=p1; // point p4(p1);  Вызов конструктора копирования
	p4.print(); 
	delete [] pP;
	// free(pP); Так не верно
	return 0;
}
```

```c++
Обращение к полям и методам класса внутри методов класса просто по имени, 
а за пределами класса через имя объекта и операцию «.» 
или через имя указателя на объект и операцию «->». 
Каждый объект класса имеет в оперативной памяти свои копии полей класса.
```
```c++
Пример работы с полями:
struct A { 
	int i; 
	void print() { 
		printf(“i=%d”, i);
	} 
};

A a1;
A *pA=&a1;

a1.i=10; 
a1.print();

pA->i=10; 
pA->print();

a1.A::i=10; 
a1.A::print();

pA->A::i=10; 
pA->A::print();
```
```c++
Компонентные данные и функции класса
Компонентные данные (поля класса) и функции класса (методы класса) уже во
многом рассмотрены выше. 
Следует добавить, что методы класса могут быть определены внутри класса, 
в этом случае они по возможности (если нет ограничений) являются подставляемыми, 
но чаще всего класс содержит описание (заголовки) методов, 
а определения методов находятся за пределами класса. 

Эта возможность является удобной в проектах, состоящих из многих файлов.

Создается отдельный файл с расширением .h (заголовочный файл), 
в котором находится описание класса вместе с полями и заголовками методов. 
Определения методов находится в файле реализации класса 
(файле с расширением .cpp). 

В этом случае, чтобы использовать класс в другом файле с исходным кодом, 
необходимо подключить заголовочный файл с описанием класса. 
Также внутри методов можно использовать умалчиваемые значения параметров 
(требования такие же, как к обычным функциям). 

В классах возможна перегрузка методов.
В следующем примере показаны перечисленные возможности:
```

```c++
struct Complex {
    double real,  
    image; // Поля класса 
    void define(double re=0.0, double im=0.0) 
    // Определение метода внутри класса, метод  будет  подставляемым
    {
        real=re; image=im;// Обращение к полям внутри метода
    }
    void print(); // Описание метода
};
void Complex::print() // Определение метода за пределами класса
{
    printf("\nreal=%f  image=%f", real, image); 
}
```

### 2. Статусы доступа компонент класса. Операции для доступа к компонентам класса, примеры.
```c++
Доступность компонент класса
Свойство доступности определяет возможность доступа к полям и методам за
пределами класса (через имя объекта или через указатель на объект).

Существуют три статуса доступа:
• public (полностью доступны за пределами класса);
• private (не доступны за пределами класса, можно обращаться к компонентам
только в методах своего класса);
• protected (доступны только в своем классе и в производных классах).
```
```
По умолчанию, если класс определен с ключевым словом struct, 
то все компоненты имеют статус доступа public. 

Если с ключевым словом union, тоже public, 
но все поля каждого объекта располагаются в памяти, 
начиная с одного адреса. 

Если класс определен с ключевым словом class, 
то все поля и методы по умолчанию имеют статус доступа private.
```
```c++
Статус доступа можно изменить с помощью соответствующих модификаторов, 
что продемонстрировано в следующем примере:

struct A
{
 …… // Статус доступа public
private:
………. // Статус доступа private
protected:
……….// Статус доступа protected
};

class B
{
 …… // Статус доступа private
public:
………. // Статус доступа public
protected:
……….// Статус доступа protected
}; 
```

```c++
Обращение к полям и методам класса внутри методов класса просто по имени, 
а за пределами класса через имя объекта и операцию «.» 
или через имя указателя на объект и операцию «->». 
Каждый объект класса имеет в оперативной памяти свои копии полей класса.
```
```c++
Пример работы с полями:
struct A { 
	int i; 
	void print() { 
		printf(“i=%d”, i);
	} 
};

A a1;
A *pA=&a1;

a1.i=10; 
a1.print();

pA->i=10; 
pA->print();

a1.A::i=10; 
a1.A::print();

pA->A::i=10; 
pA->A::print();
```

`get` `set`

```c++
#include <iostream> 
#include <vector> 
#include <string>

using namespace std;

class Avt // Класс автомобиль
{
    string marka; // Марка
    double rash; // Расход топлива на 100 км
public:
    Avt()  // Конструктор без параметров создает "пустой" объект
    {
        rash = 0; 
	marka = "";
    }
    
	void set(string mar, double r) // Функция для инициализации полей  
	                               // Для созданного "пустого" объекта
    {
        marka= mar; // Копируем строку, содержащую марку автомобиля 
	rash = r; // Задаем значение расхода топлива на 100 км
    }
    
	Avt(string mar, double r) // Конструктор для инициализации полей
    {
        marka=mar; // Копируем строку, содержащую марку автомобиля 
	rash = r; // Задаем значение расхода топлива на 100 км
    }
    
	double getRash(double dlina) const // Функция возвращает - сколько нужно топлива для
    // пробега заданного расстояния
    {
        return rash * dlina / 100.;
    }
    
	void print() const // Функция для печати полей объекта
    {
        cout << "\nmarka: " << marka << "  rashod na 100 km=" << rash;
    }
};

int main() {
	int n; // Неизвестное число объектов 
	cout << "n="; cin >> n;  // Ввод с клавиатуры n 
	double rast; // Расстояние, для которого требуется вычислить расход топлива 
	cout << "rast="; cin >> rast; // Ввод с клавиатуры расстояния 
	double SumRashod = 0; // Суммарный расход топлива для всех автомобилей 
	string str; double r; // Вспомогательные переменные для ввода марки 
						  // автомобиля и расхода топлива 
```
*Первый способ создаем массив "пустых" объектов и инициализируем их с помощью функции `set`*

```c++
	Avt *pAvt; // Указатель на массив 
	pAvt=new Avt[n]; // Для каждого объекта вызывается конструктор без параметров, 
				 	// т.е. созданы "пустые" объекты 
	vector<Avt> vecAvt(n); // Создаем пустые объекты, вызывается конструктор без параметров 
    
	// Цикл ввода данных для объектов
	for(int i=0; i<n; i++) {
    
	cout<<"Object N="<<(i+1)<<":\n"<<"marka: ";
	cin.ignore();
    
	getline(cin, str); // Ввод марки автомобиля 
	cout<<"Rashod="; cin>>r;  // Ввод расхода топлива 
	pAvt[i].set(str, r); // Вызываем функцию set для инициализации полей 
	vecAvt[i].set(str, r); // Инициализация для vector объектов
	}
    
	// Цикл печати полей для объектов
	for(int i=0; i<n; i++) pAvt[i].print();
    
	// Цикл для расчета суммарного расхода топлива
	for(int i=0; i<n; i++) SumRashod+=pAvt[i].getRash(rast);
	cout << "\nSumRashor=" << SumRashod;  // Вывод на печать суммарного расхода топлива 
    
	// Тоже делаем для vector
	SumRashod = 0;
    
	// Цикл печати полей для объектов
	for (const auto pos : vecAvt) pos.print();
    
	// Цикл для расчета суммарного расхода топлива
	for (const auto pos : vecAvt) SumRashod += pos.getRash(rast);
	cout << "\nSumRashor=" << SumRashod;  // Вывод на печать суммарного расхода топлива 
	
	return 0;
}
```

*Второй способ создаем массив указателей на объекты и далее каждый объект создается динамически с помощью конструктора с инициализацией*

```c++
	Avt **ppA; // Указатель на массив указателей 
	ppA = new Avt*[n]; // Создаем массив указателей 
	vector<Avt> vecAvt; // Параллельно создаем вектор автомобилей 
	
	for (int i = 0; i < n; i++) {
		cout << "Object N=" << (i + 1) << ":\n" << "marka: "; 
		cin.ignore(); 
		getline(cin, str); // Ввод марки автомобиля 
		cout << "Rashod="; cin >> r; // Ввод расхода топлива 
		ppA[i] = new Avt(str, r); // Создание объекта динамически 
                                  // с вызовом конструктора с параметрами 
		vecAvt.push_back(Avt(str, r)); // Добавляем объект в контейнер 
	}
	// Цикл печати полей для объектов 
	for (int i = 0; i < n; i++) ppA[i]->print(); 
	// Цикл для расчета суммарного расхода топлива
    
	for (int i = 0; i < n; i++) SumRashod += ppA[i]->getRash(rast); 
    
	cout << "\nSumRashor=" << SumRashod;  // Вывод на печать суммарного расхода топлива 
    
	// Тоже делаем для vector 
	SumRashod = 0; // Цикл печати полей для объектов 
    
	for (const auto pos : vecAvt) pos.print(); 
	// Цикл для расчета суммарного расхода топлива 
    
	for (const auto pos : vecAvt) SumRashod += pos.getRash(rast); 
	cout << "\nSumRashor=" << SumRashod;  // Вывод на печать суммарного расхода топлива 
    
	return 0;
}
```

### 3. Конструкторы и деструктор класса, конструктор копирования и конструктор перемещения, назначение, пример.

Конструкторы
```c++
Конструктор класса – специальный блок операторов (инструкций), 
вызываемый при создании объекта. 

Назначение: 
    присвоение начальных значений полям, 
    выделение памяти, 
    открытие файлов, 
    сетевых соединений и т.п. 

Имя конструктора совпадает с именем класса, 
конструктор не имеет возвращаемого значения. 

Возможна перегрузка конструкторов.
```
```c++
Конструктор может определяться как внутри класса, так и за пределами.

Формат определения конструктора внутри класса: 
    Имя_класса(Список_формальных_параметров) {Операторы_тела конструктора} 

По умолчанию класс всегда имеет конструктор копирования вида 
    A(const A& a) {… } (A – имя класса), 
создающий копию объекта (происходит копирование полей), 
и, если нет ни одного явного конструктора, 
то по умолчанию создается конструктор без параметров. 
Эти конструкторы можно переопределять. 

Конструктор копирования по умолчанию можно удалить, 
для этого в классе заголовок конструктора 
объявляется с ключевым словом delete без тела, 
например, 
    A(const A& a)=delete; 

Если нет явного конструктора копирования, 
то конструктор копирования по умолчанию будет удален при наличии явного конструктора перемещения 
(см. ниже) или оператора копирования с перемещением.
```
```c++
Примеры вызовов конструкторов:
    A a1;  A* pA=new A; // Вызываются конструкторы без параметров
    A a2(3, 4); A * pA2=new A(3, 4);
    // Вызываются конструкторы с 2-мя параметрами 

Для конструктора с одним параметром можно использовать форму:
    A a1=5; A a2=a1; 
	// Вместо 
	A a1(5); A a2(a1);
	
Ключевое слово explicit у конструктора с одним параметром запрещает это преобразование, 
допустима явная форма: 
    A a1(5); A a2(a1);
```
```c++
Пример:
class point
{
    int x, y;
public:
    point(int, int); // Конструктор с 2-мя параметрами 
	explicit point(int); // Конструктор с 1-м параметром 
	point() : x(0), y(0)  // Можно иницилизировать поля так 
	{ // Конструктор без параметров 
		// x=0; y=0;     // Или так
        cout << endl << "point()";
    }
    void print(); 
	~point(){
    printf("\nDestructor");
    }
};

point::point(int a, int b) // Определение конструктора за пределами класса 
    : x(a), y(b) // Можно так
{
    // x=a; y=b; // Или так
}

point::point(int a) // Определение конструктора за пределами класса
{
    x=a; y=0;
}

void point::print() // Определение метода за пределами класса
{
	cout<<"\nx="<<x<<" y="<<y;
}

	int main(int argc, char* argv[]) {
	point *pP=new point[10]; // Массив указателей на объеты, создается 10 объектов, 
			 // вызываются конструкторы без параметров
	point p1(12, 13); 
	p1.print();
	point p2; // Вызов конструктора без параметров 
	point p3=100; // point p3(100); Вызов конструктора с 1-м параметром Ошибка, надо
				// point p3(100); так как есть explicit у конструктора
	p2.print(); 
	p3.print();
	point p4=p1; // point p4(p1);  Вызов конструктора копирования
	p4.print(); 
	delete [] pP;
	// free(pP); Так не верно
	return 0;
}
```
Конструктор перемещения
```c++
Конструктор перемещения (move constructor)
В отличие от конструктора копирования 
(этот конструктор «работает», как правило, быстрее), 
исходный объект уже не нужен, 
но его нужно привести в форму, 
подходящую для вызова деструктора, 
чтобы  «не испортить» новый объект.

Пример: Vec(Vec&& v)  // Параметр - правосторонняя ссылка
//   : p(v.p), len(v.len) // Можно инициализировать так 
{
    p = v.p; 
	len = v.len;
    // Присвойте данным-членам исходного объекта значения по умолчанию. 
	// Это не позволяет деструктору многократно освобождать память
    v.p = nullptr; 
	v.len = 0; 
}
```
```c++
Вызов конструктора: Vec V2=std::move(V1); 

#include <stdlib.h>
#include <iostream>

class Massiv
{
public:
    int *p=nullptr; // Изначально "пустой" объект
    int n=0; 
	
	Massiv(int *pp, int nn);
    Massiv(const Massiv &M);
    
	// Конструктор перемещения 
	Massiv(Massiv&& M);  // Параметр - правосторонняя ссылка 
	
	~Massiv(); // Описание деструктора
    
	void print() const;
};
Massiv::~Massiv()
{
    if (p != nullptr) delete[]p;
    std::cout << "Destryctor\n";
}

Massiv::Massiv(const Massiv & M)
{ // Новый конструктор копирования std::cout <<"Constr Copy\n";
    n = M.n;
    p = new int[n];
    for (int i = 0; i<n; i++)
    p[i] = M.p[i];
}
// Конструктор перемещения (вариант: делаем все явно) 
/*
Massiv::Massiv(Massiv&& M)  // Параметр - правосторонняя ссылка
        : p(M.p), n(M.n)   // Можно инициализировать так 
{	
    std::cout << "Constr Move\n"; 
    //p = M.p;  // Или инициализировать так 
    //n = M.n; 
    
    // Присвойте данным-членам исходного объекта значения по умолчанию. 
    // Это не позволяет деструктору многократно освобождать память
    
    M.p = nullptr; 
    M.n = 0; 
}
*/
// Конструктор перемещения (более короткий вариант) 
Massiv::Massiv(Massiv&& M)  // Параметр - правосторонняя ссылка
{
    std::cout << "Constr Move\n";
    std::swap(p, M.p); 
	std::swap(n, M.n);
}

Massiv::Massiv(int *pp, int nn) 
{
    std::cout << "Constr\n";
    n = nn;
    p = new int[n];
    for (int i = 0; i<n; i++) p[i] = pp[i]; 
}

void Massiv::print() const
{
    if (p!=nullptr)
    for (int i = 0; i < n; i++) std::cout << p[i] << " ";
    else std::cout<<"Null Object";
    std::cout << "\n";
}

int main()
{
    int m[] = { 1, 2, 3, 4, 5, 6, 7 };
    Massiv M1(m, 7);
    
	M1.print();
    
	Massiv M2 = M1; // Massiv M2(M1); Вызывается конструктор копирования
    M2.print();
    M1.p[0] = 1000;
    M1.print(); 
	M2.print();
	
	{
        Massiv M3 = std::move(M1); // Вызов конструктора перемещения
        M3.print();
    }
	// При выходе из блока возникла бы проблема потерянной ссылки (указателя) 
    // или утечки памяти, если бы не было деструктора 
    
	Massiv *pM = new Massiv(M1);// Конструктор копирования 
    delete pM; // Автоматически вызывается деструктор
    
	return 0;
}
```

```c++
Если нет явного конструктора перемещения и копирования, 
то конструктор перемещения создается по умолчанию. 

Если есть явный конструктор копирования, 
то конструктор перемещения не создается, 
вместо него используется этот явный конструктор копирования. 

Конструктор перемещения также можно явно удалить, 
для этого в классе заголовок конструктора объявляется 
с ключевым словом delete без тела, 
например, 
    A( A&& a)=delete;
```

Деструктор
```c++
Деструктор — специальный блок операторов (инструкций), 
служащий для деинициализации объекта (освобождение памяти, закрытие файлов и т.п.).

Вызывается автоматически при удаление объекта, 
например, оператором delete или при выходе из блока, 
в котором существует объект. Не имеет возвращаемого значения и параметров. 

Может определяться как внутри класса, так и за пределами.
```
```c++
~имя_класса() {
    тело_деструктора 
}
```


### 4. Статические компоненты класса, назначение, пример.

##### Статические поля
```
Память под обычные поля (нестатические) выделяется при создание объекта, каждый
объект класса имеет свои копии обычных полей.

Статические поля объявляются в классе с модификатором static, 
память под статические поля выделяется при определении класса, 
и не выделяется при создание объектов. 

Статические поля существуют в единственном экземпляре независимо от того, 
сколько объектов создано, т.е. это поля класса, они общие для всех объектов. 

К статическим полям за пределами класса можно обращаться через имя объекта, 
как к обычным полям, но чаще к ним обращаются через имя класса 
(это можно делать даже когда объекты класса не созданы). 

Статические поля обязательно требуют инициализации (за пределами класса).
```

##### Статические методы
```
На статические поля распространяются модификаторы статуса доступа. 

Для доступа к собственным (private) 
или защищенным (protected) 
статическим полям за пределами класса служат открытые статические методы, 
которые определяются с модификатором static.

К статическим методам за пределами класса обращаются 
как к статическим полям через имя объекта 
или чаще через имя класса. 

Внутри статических методов можно обращаться только 
к статическим полям 
или вызывать другие статические методы. 

К обычным полям и методам обращаться нельзя, 
так как при вызове статического метода объекты могут быть еще не созданы 
(статический метод относится ко всему классу).
```
```c++
#include <iostream>
using namespace std;
class A{
    static int N; // Счетчик созданных объектов
public:
    A()
    {
        N++;
    }
    ~A() { N--; }
    static int getN();
};
int A::getN() 
    {
        return N;
    }
int A::N=0; // Обязательная инициализация статич поля

int main(int argc, char* argv[]) {
    cout << "N=" << A::getN(); 
	A a1, a2, a3, a4; 
	cout<<"\nN="<< a1.getN(); 
	{
    A a5; 
	cout << "\nN="<< a5.getN();
    }
cout << "\nN="<< A::getN();
return 0;
}
```

### 5. Указатель this, примеры использования.
##### Указатель `this`
```
Иногда при вызове нестатического метода требуется обращаться к адресу объекта, 
для которого вызывается метод. Но когда программист пишет код метода класса, 
объектов еще не существует. 

Для этих целей любой нестатический метод и конструкторы (деструктор) 
неявно (по умолчанию) получает указатель `this` – указатель на объект класса, 
для которого вызывается метод.
```
```c++
Первый случай использования this

class point { 
    int x,y; 
public: 
    point(int x, int y) 
    {
        this->x=x;   
        this->y=y; 
    }
…..
};
```
```c++
Второй случай использования this

class List // Линейный односвязный список 
{
    int x; // инф. поле 
    List *pNext; // Указатель на след. элемент 
public: 
    List(int x) 
    {
        this->x=x;
    }
    void add(List *&pF) // Добавить элемент в начало списка 
    {
        pNext=pF; pF=this; // Текущий элемент будет первым
    }
…………….
};
```

### 6. Указатели на компоненты класса (на функции и поля класса), назначение, пример.

##### Указатели на компоненты класса
```
Операции `.*` и `->*` предназначены для работы с указателями на компоненты класса.
До использования указателя его необходимо  соответствующим образом настроить.
```
##### Указатели на компонентные функции (методы)
Формат определения указателя на функцию:
```
<тип_возвр_значения>  (<имя_класса>::*<имя_указателя>)(<спецификация_форм_параметров>);
```
Настройка указателя:
```
<имя указателя>=  &<имя_класса>::<имя_функции>;
```
Вызов функции по указателю:
```
(<имя_объекта>.*<имя_указателя>)(<параметры>); 
(<имя_ук_на_об>->*<имя_указателя>)(<параметры>);
```

##### Указатели на поля
Формат определения указателя на поле класса:
```
<тип_поля> (<имя_класса>::*<имя_указателя>);
```
Настройка указателя:
```
<имя указателя>= &<имя_класса>::<имя_поля>;
```
Обращение к полю по  указателю:
```
<имя_объекта>.*<имя_указателя>=10; <имя_ук_на_об>->*<имя_указателя>=10;
```

```c++
#include <iostream>
using namespace std; 
struct point{
	int x, y;   
	void printX() 
	{
        cout<<endl<<"x="<<x;
    }
    void printY() 
	{
        cout<<endl<<"y="<<y;
    }
};

int main(int argc, char* argv[]) {

    void (point::*pF)()=&point::printX; // Указатель на функцию класса 
    int point::*p=&point::x; // Указатель на поле класса
    point p1;
//  p1.x=5; 
//  p1.y=10; 
    p1.*p=5; // Обращение к полю х через указатель 
    p=&point::y; // Указатель настраиваем на поле y 
    p1.*p=10; // Обращение к полю y через указатель 
    (p1.*pF)(); // Вызываем функцию printX через указатель
    pF=&point::printY;// Указатель на функцию класса настраиваем на функцию printY
    (p1.*pF)(); // Вызываем функцию printY через указатель
    return 0;
}
```


### 7. Дружественные функции и классы, назначение, пример.

```c++
Дружественные функции класса
Особенности ДФ: 
	- ДФ не получает ук-ль this, т.к. она не принадлежит классу;
	- Дружественная функция получает доступ к объекту через формальный параметр, 
		объект класса передается по указателю или по ссылке; 
	- Место размещение прототипа ДФ внутри класса безразлично, 
		на нее не распространяется действие модификаторов доступа; 
	- ДФ может быть компонентной функцией другого класса; 
	- ДФ может быть дружественной по отношению к нескольким классам.
```

```c++
Дружественные классы 
	class C1 { friend class C2; ...  }; 
	class C2 {  ....  }
Все функции класса С2 являются дружественными по отношению к классу С1.

Пример:

#include <iostream>

using namespace std;

class point
{
	int x, y;
	public:
	point(int a, int b) {
		x=a; y=b;
	}
	friend void print(point &p); // Заголовок ДФ внутри класса 
	// friend void A::fun(point &p); // Если ДФ принадлежит классу A
};

void print(point &p) // Дружественная функция
{
	cout<<endl<<"x="<< p.x<<" y="<<p.y; // Имеет доступ к закрытым полям (private)
}

int main(int argc, char* argv[]) {
	point p1(3, 5); print(p1); // Вызов ДФ
	return 0;
}

```
**Пример с семинара**
```c++
#include <iostream>

using namespace std;
class MyVec
{
    int *p=nullptr;
    int n=0;
public:
    MyVec(): p(nullptr) {
        cout<<"MyVec()"<<endl;
    }
    MyVec(int n): n(n)
    {
        p=new int[n];
        cout<<"MyVec(int n)"<<endl;
    }
    MyVec(int *p, int n){
        this->n=n;
        this->p=new int[n];
        for(int i=0; i<n; i++)
            this->p[i]=p[i];
        cout<<"MyVec(int *p, int n)"<<endl;
    }
    MyVec(const MyVec & ob)
    {
        this->n=ob.n;
        this->p=new int[n];
        for(int i=0; i<n; i++)
            this->p[i]=ob.p[i];
        cout<<"MyVec(const MyVec & ob)"<<endl;
    }
    MyVec(MyVec && ob)
    {
        swap(p, ob.p);
        swap(n, ob.n);
        cout<<"MyVec(MyVec && ob)"<<endl;
    }
    MyVec& operator=(const MyVec & ob2)
    {
        if (&ob2 != this)
        {
        if (n<ob2.n)
        {
            delete [] p;
            p=new int [ob2.n];
        }
        n=ob2.n;
        for(int i=0; i<n; i++)
            p[i]=ob2.p[i];
        }
        cout<<"MyVec& operator=(const MyVec & ob2)"<<endl;
        return *this;
    }
    MyVec& operator=(MyVec && ob2)
    {

        swap(p, ob2.p);
        swap(n, ob2.n);

        cout<<"MyVec& operator=(MyVec && ob2)"<<endl;
        return *this;
    }
    ~MyVec()
    {
        delete []p;
        cout<<"~MyVec()"<<endl;
    }
    void print(ostream & out=cout)
    {
        for(int i=0; i<n; i++)
            out<<p[i]<<' ';
        out<<endl;
    }
    MyVec & operator++()
    {
        for(int i=0; i<n; i++) ++p[i];
        return *this;
    }
    MyVec operator++(int)
    {
        MyVec ob(*this);
        for(int i=0; i<n; i++) ++p[i];
        return ob;

    }
    friend ostream & operator<<(ostream & out, const MyVec & ob);
    friend MyVec operator+(const MyVec & ob1, const MyVec & ob2);
};

ostream & operator<<(ostream & out, const MyVec & ob)
{
    for(int i=0; i<ob.n; i++)
        out<<ob.p[i]<<' ';
    out<<endl;
    return out;
}

MyVec operator+(const MyVec & ob1, const MyVec & ob2)
{
    MyVec ob(ob1.n+ob2.n);
    for(int i=0; i<ob1.n; i++)
        ob.p[i]=ob1.p[i];
    for(int i=0; i<ob2.n; i++)
        ob.p[i+ob1.n]=ob2.p[i];
    return ob;
}

MyVec CreateVec()
{
    int m1[]={1, 2, 3, 4, 5};
    MyVec V(m1, 5);
    return V;
}

int main()
{
    /*int m1[]={1, 2, 3, 4, 5};
    MyVec V1(m1, 5);
    MyVec  V2=V1;
    MyVec V3;
    V3=V1+V2;
    cout<<V3;*/
    MyVec V=CreateVec();
    cout<<V;
    return 0;
}
```

### 8. Шаблоны классов в Си++. Примеры использования.

Шаблоны классов
Шаблон класса задает семейство классов, в которых могут быть использованы разные типы.

```
template <список_параметров_шаблона> <определение_шаблона_класса>
```
Имя параметра шаблона – это имя неизвестного заранее типа.

При создании объекта указывается имя конкретного типа и по шаблону генерируется класс.


Существует библиотека стандартных шаблонов (STL- Standard Template Library), вошла в стандарт С++ 11 В ней шаблонами задаются контейнеры – предназначенные для хранение набора объектов в памяти (объекты могут быть любых типов).
Контейнеры: `vector`, `list`, `set`, `stack`, `queue`.

```c++
#include <iostream>
using namespace std;
template <class T> // Шаблон класса вектор (массив) 
		           // T - тип элементов вектора
class vektor
{   
	T* data;// Указатель на массив 
	int size;// Размерность
public:
    vektor(int n=10); 
	~vektor() { delete [] data; }
    T& operator[] (int i) // Оператор функция возвращает элемент по индексу
    {
        return data[i];
    }
    T getSum();  // Функция считает сумму элементов
};

// Внешнее определение конструктора 
template <class T> // Перед любым определением метода за пределами класса
vektor<T>::vektor(int n) 
{
    data=new T[n]; 
	size=n;
}

// Внешнее определение функции 
template <class T> // Перед любым определением метода за пределами класса
T vektor<T>::getSum() 
{
    T sum=0; 
	for(int i=0; i<size; i++) 
		sum+=data[i];
    return sum;
}
int main() 
{
    vektor<int> X(5); // Вектор элементов типа int X[1]=101;// Вызов оператор функции
    cout<<"x[1]="<< X[1];
    vektor<double> Y(10); // Создается класс вместо Т подставляется double Y[0]=10.51;// Вызов оператор функции
    cout << "\nY[0]=" << Y[0]; 
	for(int i=0; i<10; i++) Y[i]=i; 
	cout << "\nSum="<< Y.getSum();
    return 0;
}
```
Примечание.
Вместо ключевого слова class можно перед параметром шаблона использовать ключевое слово typename

```c++
template <typename T> // Шаблон класса вектор (массив) 
                      // T - тип элементов вектора
class vektor
{
    ….
};
```

### 9. Перегрузка стандартных операций (унарных, бинарных) в случае, когда оператор-функция принадлежит классу, пример.


```
Правило трёх 
(также известное как «Закон Большой Тройки» или «Большая Тройка») - правило в C++, 
гласящее, что если класс или структура определяет один из следующих методов, 
то они должны явным образом определить все три метода: 
	• Деструктор 
	• Конструктор копирования 
	• Оператор присваивания копированием 

С выходом одиннадцатого стандарта правило расширилось 
и теперь называется правило пяти. 
Теперь при реализации конструктора необходимо реализовать: 
	• Деструктор 
	• Конструктор копирования 
	• Оператор присваивания копированием 
	• Конструктор перемещения 
	• Оператор присваивания перемещением
```

```c++
Перегрузка операций в языке Си++ 
это возможность распространения действия стандартных операций на операнды, 
для которых эти операции первоначально не предназначались. 
Это возможно, если хотя бы один из операндов является объектом класса, 
для этого создается специальная, так называемая, 
оператор - функция, которая может быть как членом класса, 
так и функцией, не принадлежащей классу.

Формат определения оператор- функции имеет вид:
	<тип_возвращаемого_значения> 
	operator <знак_операции> 
	(спецификация_параметров) 
	{
		операторы_тела_функции
	}

Существует три способа перегрузки: 
	- оператор-функция определяется как функция, не принадлежащая классу; 
	- оператор-функция определяется как функция класса;
	- оператор-функция определяется как дружественная функция класса.

Особенности перегрузки операций: 
	- можно перегружать только стандартные операции, 
		например, нельзя перегрузить операцию ‘**’ 
		(возведение в степень в языке Фортран, отсутствует в Си++);
	- не допускают перегрузки операции: ‘.’, ‘.*’, ‘?:’, ‘::’, ‘sizeof’, ‘#’, ‘##’;
	- при перегрузке сохраняется арность операций 
		(унарная операция остается унарной, а бинарная – бинарной); 
	- бинарная операция перегружается либо как  функция, 
		не принадлежащая классу с двумя параметрами, 
		один обязательно объект (ссылка на объект) класса, 
		или как функция класса с одним параметром, 
		первым операндом операции выступает объект класса, 
		для которого вызывается функция; 
	- бинарные операции ‘=‘, ‘[]’, ‘->’ 
		должны обязательно определяться как компонентные функции класса; 
	- унарная операция перегружается либо как  функция, 
		не принадлежащая классу с одним параметром - объектом (ссылкой на объект) класса, 
		или как функция класса без параметров, 
		операндом операции выступает объект класса, 
		для которого вызывается функция.

```
.h
```c++
#include <string>
#include <vector>
#include <iostream>
#include <fstream>

using namespace std;

#ifndef FIREWALL_H
#define FIREWALL_H

class Vector // Класс - вектор
{
	double *point = nullptr; // Указатель на массив (вектор)
	int n = 0; // Размерность вектора (число элементов) массива
public:
	Vector(); // Конструктор без параметров, задает "пустой" объект
	Vector(double *p, int n); // Коструктор на входе массив, задающий вектор
	Vector(int n); // Конструктор - выделяем память без инициализации
	Vector(const Vector &V);  // Конструктор копирования
	Vector(Vector &&V);  // Параметр - правосторонняя ссылка
	double &operator[](int index); // Оператор - функция (перегрузка операции обращения к элементу)
	Vector &operator=(const Vector &v2); // Оператор- функция копирования объекта
	Vector &operator=(Vector &&v2); // Оператор- функция перемещения объекта
	~Vector(); // Деструктор

	friend double operator*(Vector &v1, Vector &v2); // Дружественная функция,
	friend Vector operator+(const Vector &v1, const Vector &v2); // определенная вне класса

	friend istream& operator>>(std::istream& in, Vector& vec);
	friend ostream& operator<<(std::ostream& out, const Vector& vec);

	void print(ostream& out = cout) const; // Печать вектора (массива), заменить на перегрузку <<
};

#endif //FIREWALL_H

```
.cpp
```c++
#include "Vector.h"
#include <string>
#include <iostream>
#include <fstream>

using namespace std;

Vector::Vector() // Конструктор без параметров, задает "пустой" объект
{
	point = nullptr; // Указатель на массив (вектор)
	n = 0; // Размерность вектора (число элементов) массива
	cout << "Vector()" << endl;
}

Vector::Vector(double *p, int n) // Коструктор на входе массив, задающий вектор
{
	this->n = n; // Задаем число элементов
	this->point = new double[n]; // Выделяем память
	for (int i = 0; i < n; i++) this->point[i] = p[i]; // Копируем один массив в другой
	cout << "Vector(double *p, int n)" << endl;
}

Vector::Vector(int n) : n(n) // Конструктор - выделяем память без инициализации
{
	point = new double[n];
	cout << "Vector(int n)" << endl;
}

Vector::Vector(const Vector &V) { // Конструктор копирования
	n = V.n;
	point = new double[n];
	for (int i = 0; i < n; i++) point[i] = V.point[i];
	cout << "Vector(const Vector & V) n=" << n << endl;
}

void Vector::print(ostream& out) const
{
	for (int i = 0; i < n; i++)
		cout << point[i] << " ";
	cout << endl << endl;
}

Vector::Vector(Vector &&V)  // Параметр - правосторонняя ссылка
{
	std::swap(point, V.point);
	std::swap(n, V.n);
	cout << "Vector(Vector &&V)" << endl;
}

double &Vector::operator[](int index) // Оператор - функция (перегрузка операции обращения к элементу)
{
	return point[index];
}

Vector &Vector::operator=(const Vector &v2) // Оператор- функция копирования объекта
{
	if (this != &v2) // Запрет копирования вектора самого в себя
	{
		n = v2.n;
		if (point != nullptr) delete[] point; // Освобождаем память старого вектора
		point = new double[n]; // Выделяем память для нового вектора
		for (int i = 0; i < n; i++) point[i] = v2.point[i];
	}
	cout << "Vector & operator = (const Vector& v2)" << endl;
	return *this; // Возвращаем ссылку на текущий объект
}

Vector &Vector::operator=(Vector &&v2) // Оператор - функция перемещения объекта
{
	if (this != &v2) // Запрет перемещения вектора самого в себя
	{
		std::swap(point, v2.point);
		std::swap(n, v2.n);
	}
	cout << "Vector & operator = (Vector&& v2)" << endl;
	return *this; // Возвращаем ссылку на текущий объект
}

Vector::~Vector() // Деструктор
{
	cout << "~Vector() n=" << n << endl;
	if (point != nullptr) delete[] point; // Освобождаем память
}

// Умножение числа на вектор (первый операнд не объект класса,
// функция обязательно определяется вне класса)
double operator *(Vector &v1, Vector& v2) // Оператор - функция вне класса
{
	double Res = 0;
	for (int i = 0; i < v2.n; i++) Res += v1.point[i] * v2.point[i]; // Заполняем массив
	return Res; // Возвращаем объект
}
Vector operator +(const Vector& v1, const Vector& v2) // Оператор - функция вне класса
{
	Vector V(v1.n + v2.n); // Создаем новый объект заданного размера
	for (int i = 0; i < v1.n; i++) V.point[i] = v1.point[i]; // Заполняем массив
	for (int i = 0; i < v2.n; i++) V.point[i + v1.n] = v2.point[i]; // Заполняем массив
	return V; // Возвращаем объект
}
istream& operator >> (std::istream& in, Vector& vec)
{
	in >> vec.n;
	for (int i = 0; i < vec.n; ++i) {
		in >> vec[i];
	}
	return in;
}
ostream& operator << (std::ostream& out, const Vector& vec) {
	{
		for (int i = 0; i < vec.n; i++)
			out << vec.point[i] << " ";
		out << endl;
	}
	return out;
}


```
main
```c++
#include <iostream>
#include <fstream>
#include "Vector.h"

using namespace std;

int main() {
	ifstream file;
	ofstream fout;
	vector <double> nums;

	file.open("input.txt");
	fout.open("fout.txt");

	if (file.is_open()) {
		double s;
		for (file >> s; !file.eof(); file >> s) { // пример вставки
			nums.push_back(s);
		}

		double* numsD = new double[nums.size()];

		for (int i = 0; i < nums.size(); i++) {
			numsD[i] = nums[i]; // пример обращения к операции []
		}
		int size = nums.size();
		cout << "Array:" << endl;
		Vector v1(numsD, size);
		v1.print(fout);

		cout << "Copying" << endl;
		Vector v2(numsD, size);
		v2 = v1; // пример функции копирования Vector &operator=(const Vector &v2)
		v2.print(fout);

		cout << "v1 * v2 = ";
		double Result = v1 * v2;
		cout << Result << endl << endl;

		cout << "Moving" << endl;
		Vector v4(numsD, size);
		Vector v5(numsD, size);
		v4 = move(v1); //пример функции перемещения
		v4.print(fout);

		cout << "fout" << endl;
		fout << v4;
		std::cout << std::endl;


	}

	file.close();
	fout.close();

	return 0;
}
```
### 10. Перегрузка стандартных операций (унарных, бинарных) в случае, когда оператор-функция не принадлежит классу, пример.


```
Правило трёх 
(также известное как «Закон Большой Тройки» или «Большая Тройка») - правило в C++, 
гласящее, что если класс или структура определяет один из следующих методов, 
то они должны явным образом определить все три метода: 
	• Деструктор 
	• Конструктор копирования 
	• Оператор присваивания копированием 

С выходом одиннадцатого стандарта правило расширилось 
и теперь называется правило пяти. 
Теперь при реализации конструктора необходимо реализовать: 
	• Деструктор 
	• Конструктор копирования 
	• Оператор присваивания копированием 
	• Конструктор перемещения 
	• Оператор присваивания перемещением
```

```c++
Перегрузка операций в языке Си++ 
это возможность распространения действия стандартных операций на операнды, 
для которых эти операции первоначально не предназначались. 
Это возможно, если хотя бы один из операндов является объектом класса, 
для этого создается специальная, так называемая, 
оператор - функция, которая может быть как членом класса, 
так и функцией, не принадлежащей классу.

Формат определения оператор- функции имеет вид:
	<тип_возвращаемого_значения> 
	operator <знак_операции> 
	(спецификация_параметров) 
	{
		операторы_тела_функции
	}

Существует три способа перегрузки: 
	- оператор-функция определяется как функция, не принадлежащая классу; 
	- оператор-функция определяется как функция класса;
	- оператор-функция определяется как дружественная функция класса.

Особенности перегрузки операций: 
	- можно перегружать только стандартные операции, 
		например, нельзя перегрузить операцию ‘**’ 
		(возведение в степень в языке Фортран, отсутствует в Си++);
	- не допускают перегрузки операции: ‘.’, ‘.*’, ‘?:’, ‘::’, ‘sizeof’, ‘#’, ‘##’;
	- при перегрузке сохраняется арность операций 
		(унарная операция остается унарной, а бинарная – бинарной); 
	- бинарная операция перегружается либо как  функция, 
		не принадлежащая классу с двумя параметрами, 
		один обязательно объект (ссылка на объект) класса, 
		или как функция класса с одним параметром, 
		первым операндом операции выступает объект класса, 
		для которого вызывается функция; 
	- бинарные операции ‘=‘, ‘[]’, ‘->’ 
		должны обязательно определяться как компонентные функции класса; 
	- унарная операция перегружается либо как  функция, 
		не принадлежащая классу с одним параметром - объектом (ссылкой на объект) класса, 
		или как функция класса без параметров, 
		операндом операции выступает объект класса, 
		для которого вызывается функция.

```
.h
```c++
#include <string>
#include <vector>
#include <iostream>
#include <fstream>

using namespace std;

#ifndef FIREWALL_H
#define FIREWALL_H

class Vector // Класс - вектор
{
	double *point = nullptr; // Указатель на массив (вектор)
	int n = 0; // Размерность вектора (число элементов) массива
public:
	Vector(); // Конструктор без параметров, задает "пустой" объект
	Vector(double *p, int n); // Коструктор на входе массив, задающий вектор
	Vector(int n); // Конструктор - выделяем память без инициализации
	Vector(const Vector &V);  // Конструктор копирования
	Vector(Vector &&V);  // Параметр - правосторонняя ссылка
	double &operator[](int index); // Оператор - функция (перегрузка операции обращения к элементу)
	Vector &operator=(const Vector &v2); // Оператор- функция копирования объекта
	Vector &operator=(Vector &&v2); // Оператор- функция перемещения объекта
	~Vector(); // Деструктор

	friend double operator*(Vector &v1, Vector &v2); // Дружественная функция,
	friend Vector operator+(const Vector &v1, const Vector &v2); // определенная вне класса

	friend istream& operator>>(std::istream& in, Vector& vec);
	friend ostream& operator<<(std::ostream& out, const Vector& vec);

	void print(ostream& out = cout) const; // Печать вектора (массива), заменить на перегрузку <<
};

#endif //FIREWALL_H

```
.cpp
```c++
#include "Vector.h"
#include <string>
#include <iostream>
#include <fstream>

using namespace std;

Vector::Vector() // Конструктор без параметров, задает "пустой" объект
{
	point = nullptr; // Указатель на массив (вектор)
	n = 0; // Размерность вектора (число элементов) массива
	cout << "Vector()" << endl;
}

Vector::Vector(double *p, int n) // Коструктор на входе массив, задающий вектор
{
	this->n = n; // Задаем число элементов
	this->point = new double[n]; // Выделяем память
	for (int i = 0; i < n; i++) this->point[i] = p[i]; // Копируем один массив в другой
	cout << "Vector(double *p, int n)" << endl;
}

Vector::Vector(int n) : n(n) // Конструктор - выделяем память без инициализации
{
	point = new double[n];
	cout << "Vector(int n)" << endl;
}

Vector::Vector(const Vector &V) { // Конструктор копирования
	n = V.n;
	point = new double[n];
	for (int i = 0; i < n; i++) point[i] = V.point[i];
	cout << "Vector(const Vector & V) n=" << n << endl;
}

void Vector::print(ostream& out) const
{
	for (int i = 0; i < n; i++)
		cout << point[i] << " ";
	cout << endl << endl;
}

Vector::Vector(Vector &&V)  // Параметр - правосторонняя ссылка
{
	std::swap(point, V.point);
	std::swap(n, V.n);
	cout << "Vector(Vector &&V)" << endl;
}

double &Vector::operator[](int index) // Оператор - функция (перегрузка операции обращения к элементу)
{
	return point[index];
}

Vector &Vector::operator=(const Vector &v2) // Оператор- функция копирования объекта
{
	if (this != &v2) // Запрет копирования вектора самого в себя
	{
		n = v2.n;
		if (point != nullptr) delete[] point; // Освобождаем память старого вектора
		point = new double[n]; // Выделяем память для нового вектора
		for (int i = 0; i < n; i++) point[i] = v2.point[i];
	}
	cout << "Vector & operator = (const Vector& v2)" << endl;
	return *this; // Возвращаем ссылку на текущий объект
}

Vector &Vector::operator=(Vector &&v2) // Оператор - функция перемещения объекта
{
	if (this != &v2) // Запрет перемещения вектора самого в себя
	{
		std::swap(point, v2.point);
		std::swap(n, v2.n);
	}
	cout << "Vector & operator = (Vector&& v2)" << endl;
	return *this; // Возвращаем ссылку на текущий объект
}

Vector::~Vector() // Деструктор
{
	cout << "~Vector() n=" << n << endl;
	if (point != nullptr) delete[] point; // Освобождаем память
}

// Умножение числа на вектор (первый операнд не объект класса,
// функция обязательно определяется вне класса)
double operator *(Vector &v1, Vector& v2) // Оператор - функция вне класса
{
	double Res = 0;
	for (int i = 0; i < v2.n; i++) Res += v1.point[i] * v2.point[i]; // Заполняем массив
	return Res; // Возвращаем объект
}
Vector operator +(const Vector& v1, const Vector& v2) // Оператор - функция вне класса
{
	Vector V(v1.n + v2.n); // Создаем новый объект заданного размера
	for (int i = 0; i < v1.n; i++) V.point[i] = v1.point[i]; // Заполняем массив
	for (int i = 0; i < v2.n; i++) V.point[i + v1.n] = v2.point[i]; // Заполняем массив
	return V; // Возвращаем объект
}
istream& operator >> (std::istream& in, Vector& vec)
{
	in >> vec.n;
	for (int i = 0; i < vec.n; ++i) {
		in >> vec[i];
	}
	return in;
}
ostream& operator << (std::ostream& out, const Vector& vec) {
	{
		for (int i = 0; i < vec.n; i++)
			out << vec.point[i] << " ";
		out << endl;
	}
	return out;
}


```
main
```c++
#include <iostream>
#include <fstream>
#include "Vector.h"

using namespace std;

int main() {
	ifstream file;
	ofstream fout;
	vector <double> nums;

	file.open("input.txt");
	fout.open("fout.txt");

	if (file.is_open()) {
		double s;
		for (file >> s; !file.eof(); file >> s) { // пример вставки
			nums.push_back(s);
		}

		double* numsD = new double[nums.size()];

		for (int i = 0; i < nums.size(); i++) {
			numsD[i] = nums[i]; // пример обращения к операции []
		}
		int size = nums.size();
		cout << "Array:" << endl;
		Vector v1(numsD, size);
		v1.print(fout);

		cout << "Copying" << endl;
		Vector v2(numsD, size);
		v2 = v1; // пример функции копирования Vector &operator=(const Vector &v2)
		v2.print(fout);

		cout << "v1 * v2 = ";
		double Result = v1 * v2;
		cout << Result << endl << endl;

		cout << "Moving" << endl;
		Vector v4(numsD, size);
		Vector v5(numsD, size);
		v4 = move(v1); //пример функции перемещения
		v4.print(fout);

		cout << "fout" << endl;
		fout << v4;
		std::cout << std::endl;


	}

	file.close();
	fout.close();

	return 0;
}
```


### 11. Особенности перегрузки операций ++ и – в префиксной и постфиксной формах.
```
Правило трёх 
(также известное как «Закон Большой Тройки» или «Большая Тройка») - правило в C++, 
гласящее, что если класс или структура определяет один из следующих методов, 
то они должны явным образом определить все три метода: 
	• Деструктор 
	• Конструктор копирования 
	• Оператор присваивания копированием 

С выходом одиннадцатого стандарта правило расширилось 
и теперь называется правило пяти. 
Теперь при реализации конструктора необходимо реализовать: 
	• Деструктор 
	• Конструктор копирования 
	• Оператор присваивания копированием 
	• Конструктор перемещения 
	• Оператор присваивания перемещением
```
```
Перегрузка операций `++` и `--`,
чтобы отличить `постфиксную` форму от `префиксной`,
вводится формальный параметр типа `int`.
```
```c++
Пример объявления операторов-функций внутри класса:

Vector & operator++()  // Префиксная форма операции ++ 
Vector operator++(int) // Постфиксная форма операции ++ 
                       // всегда есть формальный (фиктивный)
                       // параметр типа int
                       
Пример объявления операторов-функций за пределами класса:

Vector & operator++(Vector & V) // Префиксная форма операции ++ 
Vector operator++(Vector & V, int)  // Постфиксная форма операции ++ 
                                    // всегда есть формальный 
                                    // (фиктивный) параметр типа int
                                    
```
```
В постфиксной форме вначале с помощью конструктора копирования создаем новый объект,
в котором сохраняется начальное (старое) состояние текущего объекта,
затем текущий объект изменяется, и возвращается созданный объект.
```

### 12. Особенности перемещения объекта, продемонстрировать пример перемещения при перегрузке операции «=» (присваивание) на примере своего класса вектор, содержащем в качестве поля динамический массив элементов типа int.

```
Правило трёх 
(также известное как «Закон Большой Тройки» или «Большая Тройка») - правило в C++, 
гласящее, что если класс или структура определяет один из следующих методов, 
то они должны явным образом определить все три метода: 
	• Деструктор 
	• Конструктор копирования 
	• Оператор присваивания копированием 

С выходом одиннадцатого стандарта правило расширилось 
и теперь называется правило пяти. 
Теперь при реализации конструктора необходимо реализовать: 
	• Деструктор 
	• Конструктор копирования 
	• Оператор присваивания копированием 
	• Конструктор перемещения 
	• Оператор присваивания перемещением
```

```c++
По аналогии с конструкторами копирования и перемещения 
по умолчанию существуют в классе операторы 
присваивания с копированием и присваивания с перемещением. 
Правила создания и использования аналогичные. 
Эти операторы можно переопределять или удалять, 

например,
	A & operator=(const A & Ob) = delete; 

	A & operator=(A && Ob) = delete;
```
```c++
#include <iostream>

using namespace std;
class Vector
{
	int *p=nullptr; 
	int n=0; 
	
public:
	Vector() // "Пустой" объект
	{
		n = 0;
		p = nullptr;
	}
	
	~Vector() { 
		if (p != nullptr) delete[] p;
		cout <<  "Destructor"<<endl; 
	} // Деструктор 
	
	Vector(int *p, int n) // Создаем вектор на основе обычного массива
	{
		this->n = n;
		this->p = new int[n];
		for (int i = 0; i<n; i++) this->p[i] = p[i]; 
	}
	
	Vector(int n): n(n) // Выделяем память без инициализации
	{
		p=new int[n];
	}
	
	void print() const // Функция печати
	{
		if (p!=nullptr) for (int i = 0; i<n; i++)
			cout << p[i] << ' ';
		else cout << "Empty";
		cout << endl;
	}
	
	// Перегрузка операции обращение по индексу 
	int & operator[](int index) // ссылка позволяет изменять значение элемента
	{
		return p[index]; // Возвращаем элемент по индексу
	}
	
	int operator[](int index) const // Изменять значение нельзя
	{
		return p[index]; // Возвращаем элемент по индексу
	}
	
	Vector & operator++() // Префиксная форма операции ++
	{
		for (int i = 0; i < n; i++) ++p[i];
		return *this;
	}
	
	Vector operator++(int)  // Постфиксная форма операции ++ 
					// всегда есть формальный (фиктивный) параметр типа int
	{
		Vector temp (*this); // Создаем новый объект (старое состояние текущего объекта) 
		for (int i = 0; i < n; i++) ++p[i]; // Инкремент текущего объекта 
		return temp; // Возвращаем старое состояние объекта
	}
	
	Vector(const Vector & V) // Конструктор копирования
	{
		// Задаем новый объект
		n = V.n;
		p = new int[n];
		for (int i = 0; i<n; i++) p[i] = V.p[i];
		cout << "Constructor Copy"<<endl;
	}
	
	Vector(Vector && V) // Конструктор перемещения
	{
		// Короткая форма
		swap(p, V.p); swap(n, V.n);
		cout << "Constructor Move"<<endl;
	}
	
	Vector & operator=(const Vector & V2) // Оператор присваивания с копированием, 
	// параметр второй операнд, первый операнд - объект текущего класса
	{
		if (this!=&V2) // Запрет копирования объекта самого в себя
		{
			if (p != nullptr) delete[] p; // Очищает (удаляем) старый объект,если он есть 
			// Задаем новый объект
			n = V2.n;
			p = new int[n];
			for (int i = 0; i<n; i++) p[i] = V2.p[i]; 
		}
			cout << "operator= copy"<<endl; 
			return *this; // Возвращаем текущий объект
	}
	
	Vector & operator=(Vector && V2) // Оператарор присваивания с перемещением, 
		//Параметр второй операнд, первый операнд - объект текущего класса
	{
		if (this!=&V2) // Запрет перемещения объекта самого в себя
		{
		/*  // Все делаем явно 
		if (p != nullptr) delete[] p; // Очищает (удаляем) старый объект,если он есть
		// Задаем новый объект 
		n = V2.n; 
		p = V2.p; V2.n = 0; 
		V2.p = nullptr;
		*/ 
		
		// Короткая форма
		swap(p, V2.p); 
		swap(n, V2.n);
		}
	cout << "operator= move"<<endl; 
	return *this; // Возвращаем текущий объект
	}
	
	// Умножение вектора на число
	// на выходе новый вектор
	Vector operator*(int x) const
	{
		Vector V(n);
		for (int i = 0; i<n; i++) V[i] = p[i] * x;
		return V;
	}

	friend Vector operator*(int x, const Vector& v2); 
	friend double operator*(const double *p1, const Vector &Ob2); 

	// Чтобы получить доступ к закрытым полям класса 
	// friend Vector & operator++(Vector & V); 
	// Префиксная форма операции ++ 
	// friend Vector operator++(Vector & V, int);  
	// Постфиксная форма операции ++ всегда есть формальный (фиктивный) параметр типа int
	};

	// Умножение числа на вектор, так как 1 операнд не объект класса, 
	// то оператор - функция не принадлежит классу
	Vector operator*(int x, const Vector& v2)
	{
		Vector V(v2.n);
		for (int i = 0; i<v2.n; i++)
		V[i] = x*v2[i];
		return V;
	}

	// Скалярное произведение векторов 
	// Оператор-функция обязательно не принадлежит классу, 
	// Так как первый операнд не объект класса
	double operator*(const double *p1, const Vector &Ob2)
	{
		double sum = 0;
		for (int i = 0; i<Ob2.n; i++)
			sum += p1[i] * Ob2.p[i];
		return sum;
	}
	
	// Пример перегрузки операторов ++ вне класса 
	/*
	Vector & operator++(Vector & V) // Префиксная форма операции ++ 
	{
		for (int i = 0; i < V.n; i++) ++V.p[i]; 
		return V;
	}
	
	Vector operator++(Vector & V, int)  // Постфиксная форма операции ++ 
		// всегда есть формальный (фиктивный) параметр типа int 
	{
		Vector temp(V); // Создаем новый объект (старое состояние текущего объекта) 
		for (int i = 0; i < V.n; i++) ++V.p[i]; // Инкремент текущего объекта 
		return temp; // Возвращаем старое состояние объекта 
	}
	*/
	
	int main()
	{
	int m1[] = { 1, 2, 3, 4, 5 };
	Vector V1(m1, 5); // Создаем объект на основе обычного массива
	V1.print();
	V1[0] = 100;
	V1.print();
	
	Vector V2;
	V2 = 2 * V1; // V2=operator*(2, V1);
	V2.print();
	
	Vector V3;
	//V3 = move(V1++); // Чтобы не создавать лишние объекты используем оператор перемещения 
	V3 = V1++; // Здесь тоже вызывается оператор = с перемещением Чтобы не создавать лишние объекты
	
	V1.print(); 
	V3.print();
	return 1;
	}
```

### 13. Наследование классов. Объявление производного класса, пример использования.
```
Общие сведения о наследовании Основная идея:

На базе существующего класса (класс родитель или базовый класс),
создается производный класс (класс- наследник, дочерний класс),
который включает в себя поля и функции базового класса (наследует их),
и содержит дополнительные поля (обладает новыми свойствами) и функции.

Примеры:
```
```c++
class S: X, Y, Z { ... } ; 

class B: public A {….}; 

class D: public X, protected B 
{….};
```
```
Перед именем базового класса может указываться
статус доступа наследования или тип наследования доступа
(одно из ключевых слов public, protected, private).

Статус доступа наследования определяет статус доступа наследуемых полей и функций
из базового класса внутри производного класса.

Производный класс может определяться с ключевым словом struct или class
(с ключевым словом union производный класс не определяется).

Если производный класс определен с ключевым словом class,
то по умолчанию статус доступа наследования private.

Если производный класс определен с ключевым словом struct,
то по умолчанию статус доступа наследования public.
```
![image](https://user-images.githubusercontent.com/91723070/174835205-899c3db4-18b9-4994-826a-6440eb38558e.png)

```c++
Особенности конструкторов при наследовании 

Конструктор производного класса в первую очередь всегда 
должен вызывать конструктор базового класса. 

Если это действие не выполняется явно, 
то по умолчанию вызывается конструктор без параметров 
(если он есть, если его нет, будет ошибка). 

Если класс имеет несколько базовых, 
то конструкторы базовых классов должны вызываться в порядке 
перечисления этих классов в списке базовых.


#include <cstdlib> 
#include <iostream>

using namespace std; 

class A
{
public:
	A()
	{
		cout<<endl<<"A1";
	}
	
	A(int x) {
		cout<<endl<<"A2";
	}
};
	
class B: public A
{
public:
	B(): A(4) // Явный вызов конструктора с 1-м параметром, 
	// если нет явного вызова, то вызывается конструктор без параметров, 
	// если его нет, будет ошибка
	{
		cout<<endl<<"B";
	}
};

class C
{
public:
	/*
	C()
	{
		cout<<endl<<"C1";
	}
	*/
	
	C(int x) {
		cout<<endl<<"C2";
	}
};
	
class D: public A, public C
{
public:
	D() : A(3), C(5) // Явный вызов конструкторов
	{
		cout<<endl<<"D";
	}
};

int main(int argc, char* argv[]) 
{
	B b1; 
	D d1; 
	
	system("pause");
	return 0;
}
```
```c++
Особенности деструкторов при наследовании 
Деструктор производного класса всегда 
неявно по умолчанию после выполнения своего тела вызывает деструкторы базовых классов. 


Причем порядок разрушения объекта (вызовов деструкторов) 
обратен порядку создания (вызова конструкторов).


#include <iostream>

using namespace std; 

class A
{
public:
	~A()
	{
		cout<<endl<<"A";
	}
};

class B
{
	public:
	~B()
	{
		cout<<endl<<"B";
	}
};

class C: public A, public B
{
	public:
	~C()
	{
		cout<<endl<<"C";
	}
};

int main(int argc, char* argv[]) 
{

	{
		C c1;
	} // При выходе из блока объект с1 уничтожается - вызывается деструктор
	
	return 0;
}
```

### 14. Статусы доступа при наследовании классов.

См. вопрос 13

### 15. Конструкторы и деструктор в производных классах, примеры.
```c++
Начнем с того, что когда мы создаем элементы (переменные) класса, мы не можем присвоить им значения в самом определении класса. Компилятор выдаст ошибку. Поэтому нам необходимо создавать отдельный метод (так называемую set-функцию) класса, с помощью которого и будет происходить инициализация элементов. При этом, если необходимо создать, к примеру, 20 объектов класса, то чтобы инициализировать элементы потребуется 20 раз вызвать set-функции.

Тут нам как раз сможет помочь конструктор класса. Кстати, конструктор (от слова construct — создавать) – это специальный метод класса, который предназначен для инициализации элементов класса некоторыми начальными значениями.

В отличии от конструктора, деструктор (от слова destruct — разрушать) — специальный метод класса, который служит для уничтожения элементов класса. Чаще всего его используют тогда, когда в конструкторе,при создании объекта класса, динамически был выделен участок памяти и необходимо эту память очистить, если эти значения уже не нужны для дальнейшей работы программы.

Важно запомнить:

конструктор и деструктор, мы всегда объявляем в разделе public;
при объявлении конструктора, тип данных возвращаемого значения не указывается, в том числе — void!!!;
у деструктора также нет типа данных для возвращаемого значения, к тому же деструктору нельзя передавать никаких параметров;
имя класса и конструктора должно быть идентично;
имя деструктора идентично имени конструктора, но с приставкой ~ ;
В классе допустимо создавать несколько конструкторов, если это необходимо. Имена, согласно пункту 2 нашего списка, будут одинаковыми. Компилятор будет их различать по передаваемым параметрам (как при перегрузке функций). Если мы не передаем в конструктор параметры, он считается конструктором по умолчанию;
Обратите внимание на то, что в классе может быть объявлен только один деструктор;
Сразу хочу привести пример, который доступно покажет, как работает конструктор:


# include <iostream>
using namespace std;
 
class AB //класс
{
    private:
    int a;
    int b;
    public:
    AB()    //это конструктор:  1) у конструктора нет типа возвращаемого значения! в том числе void!!!
    //   2) имя должно быть таким как и у класса (в нашем случае AB)
    {
        a = 0;//присвоим начальные значения переменным
        b = 0;
        cout << "Работа конструктора при создании нового объекта: " << endl;//и здесь же их отобразим на экран
        cout << "a = " << a << endl;
        cout << "b = " << b << endl << endl;
    }
 
    void setAB() // с помощью этого метода изменим начальные значения заданные конструктором
    {
        cout << "Введите целое число а: ";
        cin >> a;
        cout << "Введите целое число b: ";
        cin >> b;
    }
 
    void getAB() //выведем на экран измененные значения
    {
        cout << "a = " << a << endl;
        cout << "b = " << b << endl << endl;
    }
};
 
int main()
{
    setlocale(LC_ALL, "rus");
 
    AB obj1;     //конструктор сработает на данном этапе (во время создания объекта класса)
 
    obj1.setAB();   //присвоим новые значения переменным
    obj1.getAB();   //и выведем их на экран
 
    AB obj2;     //конструктор сработает на данном этапе (во время создания 2-го объекта класса)
return 0;
}

Как видно из результата работы программы, конструктор срабатывает сразу, при создании объектов класса, поэтому, явно вызывать конструктор не нужно, он сам «приходит» :)

Хочется еще добавить, что, как и обычным функциям, мы можем передавать конструктору параметры. Через параметры, конструктору можно передавать любые данные, которые будут необходимы при инициализации объектов класса.

Рассмотрим еще один пример, это все та же программа, только в код внесены некоторые изменения. Тут же покажем принцип работы деструктора:

# include <iostream>
using namespace std;
 
class AB //класс
{
    private:
    int a;
    int b;
 
    public:
    AB(int A, int B) //эти параметры мы передадим при создании объекта в main
    {
        a = A;//присвоим нашим элементам класса значения параметров
        b = B;
        cout << "Тут сработал конструктор, который принимает параметры: " << endl;//и здесь же их отобразим на экран
        cout << "a = " << a << endl;
        cout << "b = " << b << endl << endl;
    }
 
    void setAB()
    {
        cout << "Введите целое число а: ";
        cin >> a;
        cout << "Введите целое число b: ";
        cin >> b;
    }
 
    void getAB()
    {
        cout << "a = " << a << endl;
        cout << "b = " << b << endl << endl;
    }
 
    ~AB() // это деструктор. не будем заставлять его чистить память, пусть просто покажет где он сработал
    {
        cout << "Тут сработал деструктор" << endl;
    }
};
 
int main()
{
setlocale(LC_ALL, "rus");
 
AB obj1(100, 100);  //передаем конструктору параметры
 
obj1.setAB();   //присвоим новые значения переменным
obj1.getAB();   //и выведем их на экран
 
AB obj2(200, 200);  //передаем конструктору параметры
}
Деструктор срабатывает в тот момент, когда завершается работа программы и уничтожаются все данные. Мы его не вызывали – он сработал сам. Как видно, он сработал 2 раза, так как и конструктор. Уже от себя добавлю, что, в первую очередь, он удалил второй созданный объект (где a = 200, b = 200), а затем первый (где a = 100, b = 100). «Последним пришёл — первым вышел».
```

### 16. Множественное наследование и виртуальные базовые классы, примеры.

```c++
Множественное наследование и виртуальные базовые классы 
Представление отношения наследования в виде диаграммы классов.
```
![image](https://user-images.githubusercontent.com/91723070/174837841-45aace58-eeaa-48c3-9e79-0ae603d0dd52.png)

```
Множественное наследование – это когда класс имеет в качестве базовых более одного класса.
```
![image](https://user-images.githubusercontent.com/91723070/174837886-00368f6c-98d8-40a4-81a2-f6187e0d9ebe.png)

```c++
Пример заголовков классов 

class X { ... public: int k; void f() { ... } ... }; 
class Y: public X { ... } ; 
class Z: public X { ... }; 
class A: public Y, public Z { ... }; 
	При  такой схеме наследования происходит дублирование полей и функций класса X в классе А.
	
A d; Обращение к полям и функциям при дублировании за пределами класса: 
d.A::Y::X::k=5; 
d.A::Y::X::f(); 
d.A::Z::X::k=10; 
d.A::Z::X::f(); 

или

d.Y::k=5; 
d.Y::f(); 
d.Z::k=10; 
d.Z::f(); 


Внутри класса A: 
Y::X::k=5; 
Y::X::f(); 
Z::X::k=5; 
Z::X::f(); 

или 

Y::k=5; 
Y::f(); 
Z::k=5; 
Z::f();
```

```c++
Для устранения возможность дублирования полей и методов, 
когда они наследуются из 1-го класса при множественном наследовании, 
введено понятие виртуального класса, 
в предыдущем примере класс Х должен быть объявлен как виртуальный, 
для этого используется ключевое слово virtual.

Виртуальный класс — класс, который при множественном наследовании 
дополнительно включается в классы-потомки ссылкой на объект этого класса 
во избежания дублирования. 

(Для обычного наследования в Си++ в оперативной памяти 
в объекте производного класса вначале идут поля базового класса, 
а затем поля производного, 

при виртуальном наследовании дополнительно появляется ссылка в производном классе).

Термин «виртуальный» собственно относится не к базовому классу, а к способу наследования от него. 
```
```c++
class X { ... public: int k; void f() { ... } ... }; 
class Y: virtual public X { ... } ; 
class Z: virtual public X { ... }; 
class A: public Y, public Z { ... }; 
```


### 17. Переопределение функций при наследовании классов, виртуальные функции в Си++ (таблица виртуальных функций). Статическое и динамическое связывание. Примеры.


### 18. Абстрактные и локальные классы в Си++, примеры.
```c++
Абстрактные классы - это классы, которые содержат или наследуют без переопределения хотя бы одну чистую виртуальную функцию. Абстрактный класс определяет интерфейс для переопределения производными классами.

Что такое чистые виртуальные функции (pure virtual functions)? Это функции, которые не имеют определения. Чтобы определить виртуальную функцию как чистую, ее объявление завершается значением "=0". Например, определим абстрактный класс, который представляет геометрическую фигуру:


class Figure
{
public:
    virtual double getSquare() = 0;
    virtual double getPerimeter() = 0;
    virtual void showFigureType() = 0;
};
Класс Figure является абтрактным, потому он содержит как минимум одну чистую виртуальную функцию. А в данном случае даже три таких функции. И ни одна из функций не имеет никакой реализации. Реализацию должны определять классы-наследники.

При этом мы не можем создать объект абстрактного класса:

1
Figure figure;
Определим следующую программу:


#include <iostream>
 
class Figure
{
public:
    virtual double getSquare() =0;
    virtual double getPerimeter() =0;
    virtual void showFigureType()=0;
};
class Rectangle : public Figure
{
private:
    double width;
    double height;
public:
    Rectangle(double w, double h) : width(w), height(h)
    {
    }
    double getSquare() override
    {
        return width * height;
    }
    double getPerimeter() override
    {
        return width * 2 + height * 2;
    }
    void showFigureType()
    {
        std::cout << "Rectangle" << std::endl;
    }
};
class Circle : public Figure
{
private:
    double radius;
public:
    Circle(double r) : radius(r)
    {
    }
    double getSquare() override
    {
        return radius * radius * 3.14;
    }
    double getPerimeter() override
    {
        return 2 * 3.14 * radius;
    }
    void showFigureType()
    {
        std::cout << "Circle" << std::endl;
    }
};
 
int main()
{
    Rectangle rect(30, 50);
    Circle circle(30);
     
    std::cout << "Rectangle square: " << rect.getSquare() << std::endl;
    std::cout << "Circle square: " << circle.getSquare() << std::endl;
 
    return 0;
}
Здесь определены два класса-наследника от абстрактного класса Figure - Rectangle (прямоугольник) и Circle (круг). При создании классов-наследников все они должны либо определить для чстых виртуальных функций конкретную реализацию, либо повторить объявление чистой виртуальной функции. Во втором случае производные классы также будут абстрактными.

В данном же случае и Circle, и Rectangle являются конкретными классами и реализуют все виртуальные функции.

Консольный вывод программы:

Rectangle square: 1500
Circle square: 2826
Стоит отметить, что абстрактный класс может определять и обычные функции и переменные, может иметь несколько конструкторов, но при этом нельзя создавать объекты этого абстрактного класса.


Класс, объявленный внутри функции, становится локальным для этой функции и называется локальным классом в C ++.

Имя локального класса может использоваться только локально, т.Е. Внутри функции, а не вне ее.
Методы локального класса должны быть определены только внутри него.
Локальный класс может иметь статические функции, но не статические элементы данных.
Например, в следующей программе Test является локальным классом в fun().
// C++ program without any compilation error
// to demonstrate a Local Class
#include <iostream>
using namespace std;

// Creating the class
void fun()
{
	// local to fun
	class Test {
		// members of Test class
	};
}

// Driver Code
int main() { return 0; }

```

### 19. Требования к классам, объекты которых являются элементами последовательных контейнеров. Лямбда-функции в Си++. Использование лямбда-функций в алгоритмах. Сортировка контейнера алгоритмом sort с помощью предиката, лямбда-функции и перегрузки операции «<».

```
Правило трёх 
(также известное как «Закон Большой Тройки» или «Большая Тройка») - правило в C++, 
гласящее, что если класс или структура определяет один из следующих методов, 
то они должны явным образом определить все три метода: 
	• Деструктор 
	• Конструктор копирования 
	• Оператор присваивания копированием 

С выходом одиннадцатого стандарта правило расширилось 
и теперь называется правило пяти. 
Теперь при реализации конструктора необходимо реализовать: 
	• Деструктор 
	• Конструктор копирования 
	• Оператор присваивания копированием 
	• Конструктор перемещения 
	• Оператор присваивания перемещением
```

### 20. Функциональные объекты (функторы), перегрузка операции () (вызов функции) в классах, пример использования.

```
Правило трёх 
(также известное как «Закон Большой Тройки» или «Большая Тройка») - правило в C++, 
гласящее, что если класс или структура определяет один из следующих методов, 
то они должны явным образом определить все три метода: 
	• Деструктор 
	• Конструктор копирования 
	• Оператор присваивания копированием 

С выходом одиннадцатого стандарта правило расширилось 
и теперь называется правило пяти. 
Теперь при реализации конструктора необходимо реализовать: 
	• Деструктор 
	• Конструктор копирования 
	• Оператор присваивания копированием 
	• Конструктор перемещения 
	• Оператор присваивания перемещением
```

### 21. Требования к классам, объекты которых являются элементами контейнеров set и map.


### 22. Требования к классам, объекты которых являются элементами контейнеров unordered_set и unordered_map.


### 23. Понятие особой (исключительной) ситуации в Си++. Общий формат обработки исключительных ситуаций (ключевые слова: try, catch, throw).

```c++
Определение особой (исключительной) ситуации: 
	Любая ситуация, достижимая в процессе выполнения программы, 
	может быть объявлена программистом как особая или исключительная. 
	
	Например, какая-то переменная приняла значения в заданном диапазоне 
	(вышла из заданного диапазона), встретился конец файла, 
	деление на 0, переполнение и т.д.
```
```c++
try (контролировать);
try - блок в котором создается исключение 

catch (ловить);
сatch - ловит исключение 

throw (генерировать).
throw - генератор исключения 
```
```c++
Общий формат обработки исключительных ситуаций:
try // Контролируемый блок
{
……….
 if (условие_определяющее_искл_ситуацию)
 throw значение_исключения; // Генерация исключения
……….
}

// Один или несколько обработчиков исключений
catch(тип_исключения1 имя) { операторы }
………
catch(тип_исключенияN имя) { операторы }

Механизм работы: 
	Как только выполняется оператор генерации исключения: 
	throw значение_исключения;
	управление передается за пределы контролируемого блока 
	в один из подходящих обработчиков исключений catch. 
	
	Подходящий обработчик ищется по типу исключения. 
	
	Обработчики исключений похожи на функцию с одним параметром, 
	не возвращающую значение.
	
	После выполнения одного из обработчиков управление передается оператору, 
	который первым следует за обработчиками, 
	обратно в контролируемый блок управление не передается.
```

```c++
#include <iostream>

using namespace std; 

double mydiv(double x, double y)
{
	// Обработка исключения внутри функции 
	try // Контролируемый блок
	{
	if (y==0) throw '0'; // Генерация исключения 1  тип `char` 
	if (x<0) throw "negative 1 param"; // Генерация исключения 2  тип `char *` 
	if (y<0) throw "negative 2 param"; // Генерация исключения 3  тип `char *`
	return x/y;
	}
	catch(char * str) // Обработчик исключения 2 или 3 через параметр передается значение исключения
	{
		cout<<"\nException: "<< str;
	}
	
	catch(char) // Обработчик исключения 1   для типа char
	{
		cout<<"\nException: x="<<x<<" y="<<y;
	}
	
	return 0;
}

void main() {
	cout<<"\nRez=" << mydiv(1, -2); 
}
```

![image](https://user-images.githubusercontent.com/91723070/174842260-8fdf2084-7418-4b60-965e-dd4d64f5abd3.png)
![image](https://user-images.githubusercontent.com/91723070/174842274-9f5ef4dc-153f-46a1-8cd3-c5ce9d30c7b2.png)

```c++
Стандарт С11 содержит ключевое слово noexcept (аналог throw()). 
Означает, что функция не может генерировать не обработанное исключение: 
	void myfun() noexcept;
```

### 24. Обработка исключения внутри функции, в которой сгенерировано исключение (ключевые слова: try, catch, throw), пример.

См. вопрос 23

```c++
#include <iostream>

using namespace std; 

double mydiv(double x, double y)
{
	// Обработка исключения внутри функции 
	try // Контролируемый блок
	{
	if (y==0) throw '0'; // Генерация исключения 1  тип `char` 
	if (x<0) throw "negative 1 param"; // Генерация исключения 2  тип `char *` 
	if (y<0) throw "negative 2 param"; // Генерация исключения 3  тип `char *`
	return x/y;
	}
	catch(char * str) // Обработчик исключения 2 или 3 через параметр передается значение исключения
	{
		cout<<"\nException: "<< str;
	}
	
	catch(char) // Обработчик исключения 1   для типа char
	{
		cout<<"\nException: x="<<x<<" y="<<y;
	}
	
	return 0;
}

void main() {
	cout<<"\nRez=" << mydiv(1, -2); 
}
```

### 25. Обработка исключения вне функции, в которой сгенерировано исключение, объявление функции, в которой генерируются исключения (ключевые слова: try, catch, throw), пример.

![image](https://user-images.githubusercontent.com/91723070/174842501-404d1572-9f1f-4e6b-9bd7-36304f623f33.png)
```c++
Стандарт С11 содержит ключевое слово noexcept (аналог throw()). 
Означает, что функция не может генерировать не обработанное исключение: 
	void myfun() noexcept;
```

### 26. Создание исключения как объекта класса в Си++ (ключевые слова: try, catch, throw), пример.

![image](https://user-images.githubusercontent.com/91723070/174844134-7506be52-8fae-4618-aa7c-9e89cbe125f7.png)

```c++
Основная идея: 
	Функция, сталкивающаяся с неразрешимой проблемой, 
	формирует исключение в надежде на то, 
	что вызывающая ее (прямо или косвенно) функция 
	сможет обработать исключение.
```

### 27. Формы обработчиков исключений (catch), примеры.

```c++
Формы обработчиков исключений 

После блока try может быть несколько обработчиков исключений, 
существует три различные формы: 

	catch(тип_искл имя_искл) {…..} 
	
	catch(тип_исключения) {…..} 
	/* не предусматривает использование значения исключения, важен тип */ 

	catch(…) {…..} 
	// Подходит для исключения любого типа 
	// обработчик должен быть последним
```
```c++
#include <iostream>
using namespace std;
class ZeroDivide {}; 
class Overflow {};
float mydiv(float x, float y)
{
	if (y==0) throw ZeroDivide(); 
	double z=x/y; 
	if (z>1e+30) throw Overflow();
	if (z==0) throw 1; // Исключение типа int 
			// (Сработает универсальный обработчик)
	return z;
}

void main() {
	try
	{
		cout<<"\nRez="<< mydiv(1e20, 1e-20);
	}
	catch(Overflow) // Важен тип исключения имя параметра отсутствует
	{
		cout<<"\nOverflow";
	}
	catch(ZeroDivide) {
		cout<<"\nZeroDivide"; // Важен тип исключения имя параметра отсутствует
	}
	catch(...) // Обработчик без типа подходит для любого исключения должен быть последним
	{
		cout<<"\nException";
	}
}
```
```c++
Сравнения по типам в обработчиках имеет более широкий смысл, 

например, 
	обработчик catch(T t) {…..} подходит для обработки исключений типа: 
		const T, T&, const T&, 
		и типов производных классов от T.
```

### 28. Формы выражений генерации исключений в Си++ (throw), примеры.

```c++
Формы выражений генерации исключений 2 формы выражений генерации исключений: 

	throw выражение; 
	/* 
	Исключение формируется как статический объект, 
	значение которого определяется выражением генерации 
	*/ 
	
	throw;
```
```c++
#include <iostream>
using namespace std; 
double mydiv(double x, double y)
{
	try
	{
		if (y==0) throw "ZeroDivide"; // Тип исключения `char *` 
		if (y<0) throw y; // Тип исключения double
		return x/y;
	}
	catch(char *str)
	{
		cout<<str;
	}
	catch(double y)
	{
		throw; // Ретрансляция исключения во внешний блок
	}
	return 0;
}

void main() {
	try  // Внешний блок try
	{
		cout<<"\nRez="<< mydiv(9, -4);
	}
	catch(double a) // Сюда передается исключение из внутреннего блока
	{
		cout<<"\nException: a="<< a;
	}
}
```
```c++
Оператор «ретранслирует» уже существующее исключение 
в блок try верхнего уровня, 
используется внутри блока catch в случае вложенных блоков try.

При вложении контролируемых блоков исключение, 
возникшее во внутреннем блоке, последовательно «просматривает» обработчики, 
переходя от внутреннего блока к внешнему, 
до тех пор, пока не будет найден подходящий обработчик. 

Если во всей совокупности обработчиков не будет найден подходящий, 
то выполняется аварийное завершение программы 
```

### 29. Обработка исключений в стандартной библиотеке Си++: обзор основных классов.

```c++
Все исключения являются производными от класса exception 
(пространство имен std, заголовочный файл exception). 

Класс содержит строку текста с описанием исключения (char *), 
есть конструктор для инициализации этой строки в производных классах от exception, 
в классе exception строка содержит «std::exception», 
чтобы получить указатель на строку, вызывается метод char * what();
```
```c++
Исключения можно разделить на 3 категории: 
	* языковая поддержка; 
	* логические ошибки; 
	* ошибки времени выполнения.
```
![image](https://user-images.githubusercontent.com/91723070/174845689-20afcbe0-44a3-4a8e-9681-24989501a7de.png)

```c++
#include <string.h> 
#include <iostream> 
#include <exception>

using namespace std;

struct mydata: public exception 
// Класс для задания исключения при создании в полях хранится дополнительная информация об исключении
{
	double x, y; 
	mydata(double a, double b) : exception() {
		x=a; 
		y=b;
	}
};

double div(double x, double y)
{
	if (y == 0) throw exception();  // Исключение класса exception 
	if (y<0 || x<0) throw mydata(x, y); // Исключение класса производного от exception
	return x/y;
}

int main() {
	try
	{
		cout<<"Rez="<< div(5., -0.5)<<endl; 
	}
	catch(mydata & d) // Обработчик класса производного от exception
	{
		cout << endl << d.what()<< " x="<< d.x<<" y="<<d.y;
	}
	catch (exception & d) // Обработчик класса exception
	{
		cout << endl << d.what();
	}
	return 1;
}
```
```c++
Все функции в определении класса exception 
имеют пустую спецификацию noexcept (или ранее throw()).

Исключения языковой поддержки используются на уровне языка C++. 
Эти исключения генерируются при неудачных попытках выполнения некоторых операций.

Некоторые классы: 
	- исключение класса bad_alloc генерируется при 
		неудачном выполнении глобального оператора new 
		(кроме версии new с запретом исключений);
	
	- исключение класса bad_cast генерируется оператором dynamic_cast, 
		если преобразование типа по ссылке во время выполнения завершается неудачей; 
	
	- исключение класса bad_typeid генерируется оператором typeid, 
		предназначенным для идентификации типов по время выполнения, 
		если аргументом typeid является ноль или null-указатель, 
		генерируется исключение; 
	
	- исключение класса bad_exception предназначено для обработки непредвиденных исключений.
```
```c++
Логические ошибки обусловлены нарушением внутренней логики программы.
Предполагается, что их можно найти и предотвратить еще до начала выполнения программы.

Базовый класс для логических ошибок:

class logic_error : public exception

В стандартной библиотеке определены следующие классы для логических ошибок 
(заголовки классов):

	class invalid_argument : public logic_error  // неверный аргумент 
	
	class out_of_range : public logic_error  // вне диапазона 
	
	class length_error : public logic_error  // неверная длина 
	
	class domain_error : public logic_error  // вне допустимой области
	
	
Ошибки времени выполнения связаны с событием,  с самой программой не связанным.
Предполагается, что их нельзя обнаружить, пока программа не начала работать.
```
```c++
Базовый класс:
	class runtime_error : public exception  // ошибка времени выполнения

Классы ошибок времени выполнения:
	class range_error : public runtime_error  // ошибка диапазона

Функция может возбудить исключение range_error, чтобы сообщить об ошибке во внутренних вычислениях.
	class overflow_error : public runtime_error  // переполнение 

	class underflow_error : public runtime_error { // потеря значимости
```



### 30. Обработка исключений в стандартной библиотеке Си++: создание своего класса исключения на основе класса std::exception, пример.


### 31. Многозадачность в стандартной библиотеке C++: высокоуровневый интерфейс (функция std::async() и шаблон класса std::future< >), пример создания потока и получение результата потоковой функции.


### 32. Многозадачность в стандартной библиотеке C++: низкоуровневый интерфейс (использование класса std::thread), пример.


### 33. Синхронизация в стандартной библиотеке C++. Использование класса std::mutex (взаимное исключение), пример.

```c++
int main()
{
    unsigned long long g_count = 0;
    std::mutex g_count_mutex;

    std::thread t1([&]()
    {
        for(auto i = 0; i < 1'000'000; ++i) {
            g_count_mutex.lock();
            g_count += 1;
            g_count_mutex.unlock();
        }
    });
    
    std::thread t2([&]()
    {
        for(auto i = 0; i < 1'000'000; ++i) {
            g_count_mutex.lock();
            g_count += 1;
            g_count_mutex.unlock();
        }
    });
    
    t1.join();
    t2.join();
    
    std::cout << g_count;

    return 0;
}

В этом примере поток перед тем как изменить переменную захватывает mutex (устанавливает флаг о том, что переменная занята), а другой поток, пытаясь захватить тот же mutex в это же время, обнаруживает, что первый поток уже работает с переменной, и дожидается её освобождения.

Подробнее про mutex:

std::mutex
Используя mutex в примере выше, мы синхронизируем работу потоков. Mutex является примитивом синхронизации.

Примитивы синхронизации – механизмы, позволяющие реализовать взаимодействие потоков, например, единовременный доступ только одного потока к критической области.

Примитивы синхронизации преследуют различные задачи:

Взаимное исключение потоков – примитивы синхронизации гарантируют то, что единовременно с критической областью будет работать только один поток.

Синхронизация потоков – примитивы синхронизации помогают отслеживать наступление тех или иных конкретных событий, то есть поток не будет работать, пока не наступило какое-то событие. Другой поток в таком случае должен гарантировать наступление данного события.
```


### 34. Использование для синхронизации потоков блокировок – шаблона std::lock_guard, пример.


### 35. Использование условных переменных (объекты класса std::condition_variable) для синхронизации потоков в стандартной библиотеке C++: посылка и принятие оповещений потоками, примеры.


### 36. Использование атомарных операций (шаблон std::atomic) для синхронизации потоков в стандартной библиотеке C++.


### 37. Умный указатель (smart pointer) std::unique_ptr, внутреннее устройство, пример использования.
```
Правило трёх 
(также известное как «Закон Большой Тройки» или «Большая Тройка») - правило в C++, 
гласящее, что если класс или структура определяет один из следующих методов, 
то они должны явным образом определить все три метода: 
	• Деструктор 
	• Конструктор копирования 
	• Оператор присваивания копированием 

С выходом одиннадцатого стандарта правило расширилось 
и теперь называется правило пяти. 
Теперь при реализации конструктора необходимо реализовать: 
	• Деструктор 
	• Конструктор копирования 
	• Оператор присваивания копированием 
	• Конструктор перемещения 
	• Оператор присваивания перемещением
```
```
Умные указатели (smart pointers) набор классов (шаблонов классов) библиотеки С++.

Назначение – автоматизировать работу с динамической памятью, 
основная цель предотвращение утечки памяти.

Объекта класса типа умного указателя поддерживает основные операции
применяемые к обычным (иногда используется термин «сырой» указатель) указателям,
такие как, *, -> за счет перегрузки этих операций.

При в умных указателях применяется принцип Resource Acquisition Is Initialization
(RAII) – «Получение ресурса есть инициализация», смысл которого заключается в том, 
что с помощью тех или иных программных механизмов получение некоторого ресурса
неразрывно совмещается с инициализацией, а освобождение — с уничтожением объекта. 

В частности, для умного указателя как объекта класса автоматически вызывается деструктор,
которой и должен освободить динамическую память, являющуюся ресурсом для указателя.

Для использования умных указателей подключается заголовочный файл <memory>
```
```
**std::unique_ptr простейший умный указатель, является шаблоном класса
(перегруженным шаблоном, существует два шаблона: 
	один для отдельного объекта, 
	второй – для массива объектов)**. 

Указатель unique_ptr всегда полностью владеет объектом, т.е. на
один объект указывает только один указатель, 
на один объект не могут указывать два или более указателей. 
Поэтому в шаблоне класса конструктор 
**копирования и оператор присваивания с копированием удалены**, 
**конструктор перемещения и оператор присваивания с перемещением присутствуют**
```
```c++
Для создания указателя std::unique_ptr рекомендуется использовать глобальную
шаблонную функцию std::make_unique, которая получает параметры как у конструктора
объекта, на который указывает указатель.

int main()
{
	unique_ptr<A> pA=make_unique<A>(1, 2);
	cout<<*pA<<endl;
	return 0;
}
```

```cpp
//Мой пример ответа на вопрос:
/*
 * Умные указатели - набор классов шаблонов предназначенных для автоматизации работы с динамической памятью.
 * Используется прицип RAII - получение ресурса есть инициализация.
 *
 *
 * std::unique_ptr
 * - Основная фича : на один объект может указывать тоьлко один указатаель. 
 *   Соответственоо, у него отсутсвуют конструктор и оператор присваивания копированием. 
 *   Но должны быть перемещения
 *   std::unique_ptr<type> pA(new obj())
 *
 *   рекомендуется использовать make_unique
 *
 *   std::unique_ptr<type> pA = std::make_unique<type>(args);
 *
 *
 */


#include <iostream>
#include <memory>


struct A {
	int a;
	int *p = nullptr;

	A(int a) : a(a) {
		p = new int[100];
	};
	A() {a=0;};
	~A() {
	delete p;
	std::cout << "~A()" << std::endl;
	};




};

std::ostream &operator<<(std::ostream & out, A &obj){

	out << "a = " << obj.a<< std::endl;
	return out;
}



int main() {

std::unique_ptr pA = std::make_unique<A>(5);

std::cout << *pA << std::endl;
pA->a = 505;
std::cout << *pA << std::endl;

//std::cout << pA->a << std::endl;
}

```


### 38. Умный указатель (smart pointer) std::shared_ptr, внутреннее устройство, пример использования.

```
В отличии от unique_ptr разрешает копирование, 
таким образом, на один объект могут указывать два или более указателей. 

По аналогии с unique_ptr рекомендуется 
объект с указателем shared_ptr создавать с помощью глобальной функции std::make_shared 
(также передаются параметры конструктора объекта класса).

Пример создания объекта:

int main()
4 // ?
{
	shared_ptr<A> pA=make_shared<A>(1, 2);
	cout<<*pA<<endl;
	return 0;
}

shared_ptr должен каким-то образом знать, а существуют ли другие shared_ptr,
которые указывают на тот же самый объект. 

Когда для shared_ptr вызывается деструктор,
то он должен определить, удалять объект, на который он указывает, или нет. 

Если существуют другие shared_ptr, указывающие на этот же объект, 
то объект не удаляется, если других shared_ptr, указывающих на объект не существует, 
то объект удаляется. 

Для этого в динамической памяти (куче) создается небольшой объект ControlBlock. 
В этом контрольном блоке сохраняется счетчик ссылок, 
т.е. текущее количество shared_ptr указывающих на текущий объект. 

У себя shared_ptr хранит указатель на этот контрольный блок. 
Таким образом shared_ptr имеет два указателя: на сам объект и на контрольный блок.
При создании копии указателя копируются два указателя 
и в контролируем блоке счетчик объектов увеличивается на 1. 
В деструкторе shared_ptr в контролируемом блоке счетчик объектов уменьшается на 1, 
если он стал равен 0, это значит - удаляется последний shared_ptr, 
указывающий на объект и объект уничтожается, 
также освобождается память, выделенная для ControlBlock.

При перемещении shared_ptr счетчик в ControlBlock не изменяется. 
Но в случае перегрузки оператора присваивания с копированием или перемещением. 
Если объект, в который копируем или перемещаем, отличается от копируемого или перемещаемого 
и не является пустым, то для этого объекта уменьшаем счетчик ссылок на 1, 
если счетчик равен 0, то объект удаляем, и удаляем счетчик ссылок для него.
Значение счетчика можно получить с помощью функции класса:
long use_count() const noexcept
```

```cpp
//Пример моего решения 
/*
 * shared_ptr отличается от unique тем, что создает объект ControlBlock с 
 * счётчиком кол-ва указателей  на данный объект.
 * При освобождении указателся, проверяется, существуют ли другие shared_ptr
 * если да, то деструторк объекта не вызвавется
 * если нет, то вызывается и удаляется ообъект
 *
 *
 * Значение счетчика long use_count() const noexcpet
 */







#include <iostream>
#include <memory>

struct A {
	int a;
	int *p = nullptr;

	A(int a) : a(a) {
		p = new int[100];
	};
	A() {a=0;};
	~A() {
	delete p;
	std::cout << "~A()" << std::endl;
	};




};

std::ostream &operator<<(std::ostream & out, A &obj){

	out << "a = " << obj.a<< std::endl;
	return out;
}



int main() {

	std::shared_ptr<A> pA1 = std::make_shared<A>(2);
	std::shared_ptr<A> pA2 = std::make_shared<A>(5);
	std::cout << "Counters : "<<pA1.use_count() << " " << pA2.use_count() << std::endl;
	std::cout << "Class fields : "<<pA1->a << " " << pA2->a << std::endl;
	std::shared_ptr<A> pA1cp = pA1;
	std::shared_ptr<A> pA2cp = pA2;
	std::cout << "Counters : "<<pA1.use_count() << " " << pA2.use_count() << std::endl;
	std::cout << "Class fields : "<<pA1->a << " " << pA2->a << std::endl;

}
```

### 39. Умный указатель (smart pointer) std::weak_ptr, назначение, пример использования.

```
Не владеющий (слабый) указатель. 
Можно проинициализировать указателем shared_ptr при этом значение счетчика ссылок не увеличится. 
С помощью метода weak_ptr::lock() получаем shared_ptr для объекта, 
если объект существует (существует хотя бы один shared_ptr для объекта). 
Если объект уже не существует (перестали существовать все shared_ptr на него), 
то lock() вернет «пустой» shared_ptr.
```

```cpp
int main()
{
	weak_ptr<A> pA_W;
	{
		shared_ptr<A> pA=make_shared<A>(1, 2);
		pA_W=pA; // Инициализация weak_ptr
		cout<<pA_W.use_count()<<endl; // 1
		auto p=pA_W.lock(); // p имеет тип shared_ptr<A>

		if (p)
		cout<<*p<<endl; // Печатается объект

		else cout<<"Object deleted!!!"<<endl;
		cout<<pA_W.use_count()<<endl; // 2
	} // При выходе из блока все shared_ptr<A> уничтожаются

	auto p=pA_W.lock(); // Вернет пустой shared_ptr<A>

	if (p)
	cout<<*p<<endl;

	else cout<<"Object deleted!!!"<<endl; // Печатается Object deleted!!!
	cout<<pA_W.use_count()<<endl; // 0

	return 0;
}
```




### 40. Перегрузка операторов new и delete.


### 41. Размещающий оператор new и его перегрузка.


### 42. Передача дополнительных параметров в оператор new при его перегрузке.


### 43. Дополнительные операции преобразования типов: const_cast, dynamic_cast, static_cast, reinterpret_cast.


### 44. Понятие о динамической идентификации типов в Си++. Операция typeid. Основные функции класса typeinfo. Примеры использования.
